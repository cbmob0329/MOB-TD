<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB TD – グリッド分離版（テスト調整）</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --app-w: 420px;
    --row-hud: 56px;
    --row-controls: 160px;
    --hud-bg: #0e1118f0;
    --hud-fg: #eaf3ff;
    --hud-accent: #4dd0ff;
    --panel-bg: #0b1424f2;
    --panel-stroke: #1b2a44;
    --panel-shadow: 0 10px 28px rgba(0,0,0,.4);
    --hp-green: #4caf50;
    --hp-red:   #ef5350;
  }
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;overscroll-behavior:none}
  *{box-sizing:border-box}
  #root{position:fixed;inset:0;display:grid;place-items:center}
  #app{
    width:min(100vw,var(--app-w));
    height:100dvh;
    display:grid;
    grid-template-rows: calc(var(--row-hud) + env(safe-area-inset-top)) 1fr calc(var(--row-controls) + env(safe-area-inset-bottom));
    background:#05080f;
    border:1px solid #0e1522; border-radius:18px; overflow:hidden;
    box-shadow:0 14px 48px rgba(0,0,0,.55);
  }
  header.hud{
    display:flex; align-items:center; gap:8px;
    padding:8px 10px calc(8px + env(safe-area-inset-top)) 10px;
    background:linear-gradient(to bottom,#020409,#0b1220);
    border-bottom:1px solid #0f1b2e;
  }
  .pill{
    background:var(--hud-bg); color:var(--hud-fg);
    border:1px solid #1b2638; border-radius:999px; padding:6px 10px; font-size:14px;
    display:flex; align-items:center; gap:8px;
    box-shadow:0 2px 8px rgba(0,0,0,.25);
  }
  .pill b{color:var(--hud-accent)}
  .spacer{flex:1}
  .tiny{font-size:12px; opacity:.9}
  .clickable{cursor:pointer}
  main.play{position:relative; background:#000;}
  #view{position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated; display:block;}
  .center-msg{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:8px 12px; border-radius:10px; background:#00000099; border:1px solid #24324f;
    font-size:12px; text-align:center; pointer-events:none;
  }
  footer.controls{
    padding:10px 10px calc(12px + env(safe-area-inset-bottom)) 10px;
    background:linear-gradient(to top,#091323,#0b1424cc);
    border-top:1px solid #0f1b2e;
  }
  .grid2{height:100%; display:grid; grid-template-columns:1fr 1fr; gap:10px;}
  .card{
    background:var(--panel-bg); color:#e7f1ff;
    border:1px solid var(--panel-stroke); border-radius:14px; padding:10px;
    display:grid; align-content:start; gap:8px; text-align:center;
    box-shadow:var(--panel-shadow);
  }
  .card h3{margin:0; font-size:14px; letter-spacing:.3px}
  .cost{font-size:12px; opacity:.9}
  .btn{
    appearance:none; border:1px solid #2a3751; background:#122034; color:#e9f3ff; border-radius:10px;
    padding:10px 12px; font-weight:700; font-size:14px; cursor:pointer;
    box-shadow:inset 0 0 0 1px #19314e, 0 2px 10px rgba(0,0,0,.25);
  }
  .btn:disabled{opacity:.5; filter:grayscale(.3); cursor:not-allowed}
  .hint{font-size:11px; opacity:.8}
</style>
</head>
<body>
<div id="root">
  <div id="app">
    <header class="hud">
      <div class="pill" id="coinBox">💰 <b id="coins">0</b></div>
      <div class="pill tiny" id="income">+8 / 3s</div>
      <div class="spacer"></div>
      <div class="pill tiny" id="fpsBox">FPS: <b id="fps">60</b></div>
      <div class="pill tiny clickable" id="pausePill">⏸ Pause</div>
    </header>

    <main class="play">
      <canvas id="view"></canvas>
      <div class="center-msg" id="msg">下のボタンでユニットを出撃できます</div>
    </main>

    <footer class="controls">
      <div class="grid2">
        <div class="card">
          <h3>MOB段ボール</h3>
          <div class="cost">コスト <b>50</b> / HP150 / 近接</div>
          <button class="btn" id="btnBox">出撃</button>
          <div class="hint">C1〜C4.png を使用</div>
        </div>
        <div class="card">
          <h3>MOBファイター</h3>
          <div class="cost">コスト <b>120</b> / HP120 / 近接（速）</div>
          <button class="btn" id="btnFtr">出撃</button>
          <div class="hint">EN1-1〜EN1-5.png を使用</div>
        </div>
      </div>
    </footer>
  </div>
</div>

<script>
(() => {
  // ====== 画像パス（同フォルダ） ======
  const IMAGES = {
    bg: "sora.png",
    floor: "doro.png",
    towerL: "T1.png",
    towerR: "T2.png",
    BOX: { idle:"C1.png", walk:["C2.png","C3.png"], atk:"C4.png" }, // 段ボールは攻撃1枚
    FTR: { idle:"EN1-1.png", walk:["EN1-2.png","EN1-3.png"], atk:["EN1-4.png","EN1-5.png"] }
  };

  // ====== DOM ======
  const canvas = document.getElementById("view");
  const ctx = canvas.getContext("2d");
  const playEl = document.querySelector("main.play");
  const coinsEl = document.getElementById("coins");
  const fpsEl = document.getElementById("fps");
  const msgEl = document.getElementById("msg");

  // ====== プレイ領域に合わせたキャンバス ======
  let W = 420, H = 560;
  function measure(){
    const r = playEl.getBoundingClientRect();
    W = Math.max(320, Math.round(r.width));
    H = Math.max(360, Math.round(r.height));
    canvas.width = W;
    canvas.height = H;
  }
  measure();
  addEventListener("resize", measure);

  // ====== 幾何（地面をプレイ領域下部に固定） ======
  function geom(){
    const groundBandH = Math.round(H * 0.22);
    const groundTopY  = H - groundBandH;
    const GROUND_Y    = groundTopY + Math.round(groundBandH*0.85);
    const L_TOWER_X   = Math.round(W * 0.09);
    const R_TOWER_X   = Math.round(W * 0.91);
    return { groundBandH, groundTopY, GROUND_Y, L_TOWER_X, R_TOWER_X };
  }

  // ====== 定数 ======
  const COIN_TICK = 3000, COIN_ADD = 8;
  const MELEE_RANGE = 26;
  const PX_PER_SPEED = 18;
  const WALK_FPS = 6, ATK_FPS = 7;

  // 段ボールの「立ち絵→攻撃」演出長さ
  const BOX_ATK_IDLE_PHASE = 0.18; // 攻撃開始からこの時間は立ち絵を表示
  const BOX_ATK_TOTAL      = 0.36; // 1サイクルの目安（描画側のみ）

  // ====== ユニット定義 ======
  const UNIT_KINDS = {
    BOX: { name:"MOB段ボール", hp:150, atk:20, atkInt:1.0, speed:3, cost:50, imgs:"BOX", scale:0.6 },
    FTR: { name:"MOBファイター", hp:120, atk:30, atkInt:0.7, speed:5, cost:120, imgs:"FTR", scale:0.6 }
  };

  // ====== 画像読み込み ======
  function loadImage(src){
    return new Promise((res)=>{ const img=new Image(); img.src=src; img.onload=()=>res(img); img.onerror=()=>res(null); });
  }
  const assets = {};
  async function loadAll(){
    assets.bg = await loadImage(IMAGES.bg);
    assets.floor = await loadImage(IMAGES.floor);
    assets.towerL = await loadImage(IMAGES.towerL);
    assets.towerR = await loadImage(IMAGES.towerR);
    for(const key of ["BOX","FTR"]){
      const set = IMAGES[key];
      assets[key] = { idle:null, walk:[], atk:[] };
      assets[key].idle = await loadImage(set.idle);
      for(const s of (Array.isArray(set.walk)?set.walk:[set.walk])) assets[key].walk.push(await loadImage(s));
      for(const s of (Array.isArray(set.atk)?set.atk:[set.atk])) assets[key].atk.push(await loadImage(s));
    }
  }

  // ====== 状態 ======
  let coins = 500;                 // ★ テスト用：初期500コイン
  let lastCoinTick = 0, paused = false;
  let lastTime = performance.now(), fpsSmoothed = 60;

  const towerL = { x:0, y:0, hp:1200, side:+1 };
  const towerR = { x:0, y:0, hp:1200, side:-1 };

  const allies = [], enemies = [];
  const hits = [];

  let enemyQueue = [{kind:"BOX"},{kind:"BOX"},{kind:"BOX"},{kind:"BOX"},{kind:"BOX"}];
  let enemyActive = false;

  // ====== 色補間 ======
  function mixHex(a,b,t){
    function toRGB(h){const n=parseInt(h.slice(1),16);return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}}
    function toHex(r,g,b){return "#"+[r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("")}
    const A=toRGB(a), B=toRGB(b);
    return toHex(
      Math.round(A.r*(1-t)+B.r*t),
      Math.round(A.g*(1-t)+B.g*t),
      Math.round(A.b*(1-t)+B.b*t)
    );
  }

  // ====== ユニット ======
  class Unit{
    constructor(kindKey, side){
      const def = UNIT_KINDS[kindKey];
      this.kind = kindKey; this.side = side;
      const g = geom();
      this.x = side>0 ? (g.L_TOWER_X + 28) : (g.R_TOWER_X - 28);
      this.y = g.GROUND_Y;
      this.maxHp = def.hp; this.hp = def.hp;
      this.atk = def.atk; this.atkInt = def.atkInt; this.cool=0;
      this.speed = def.speed * PX_PER_SPEED;
      this.scale = def.scale;
      this.state = "walk"; this.animT = 0;
    }
    width(){ return 64*this.scale; }
    height(){ return 64*this.scale; }

    findTarget(){
      const foes = this.side>0 ? enemies : allies;
      let nearest=null, best=Infinity;
      for(const f of foes){
        if(f.state==="dead") continue;
        const d = Math.abs(f.x - this.x);
        if(d<best){best=d; nearest=f;}
      }
      const foeTower = this.side>0 ? towerR : towerL;
      const dT = Math.abs(foeTower.x - this.x);
      if(dT<best){best=dT; nearest=foeTower;}
      return {target:nearest, dist:best};
    }

    step(dt){
      if(this.state==="dead") return;
      this.cool = Math.max(0, this.cool - dt);
      const { target, dist } = this.findTarget();
      const inRange = target && dist <= MELEE_RANGE;

      if(inRange){
        if(this.cool===0){
          this.state="atk";
          this.animT=0;
          // ダメージは即時適用（視覚は「立ち→攻撃」で表現）
          if(target.hp!==undefined){ target.hp -= this.atk; flash(target); }
          this.cool = this.atkInt;
        }
      }else{
        this.state="walk";
        this.x += this.side * this.speed * dt;
        const g = geom();
        const limitL = g.L_TOWER_X + 18;
        const limitR = g.R_TOWER_X - 18;
        if(this.side>0 && this.x>limitR) this.x = limitR;
        if(this.side<0 && this.x<limitL) this.x = limitL;
      }

      if(this.hp<=0) this.state="dead";
      this.animT += dt;
    }

    draw(ctx){
      if(this.state==="dead") return;
      const A = assets[this.kind];
      let img=null;

      if(this.state==="walk"){
        img = A.walk[Math.floor(this.animT*WALK_FPS)%Math.max(1,A.walk.length)] || A.idle;

      }else if(this.state==="atk"){
        if(this.kind==="BOX"){
          // ★ 段ボール専用：「立ち絵 → 攻撃」2段演出
          const phase = this.animT % (BOX_ATK_TOTAL);
          img = (phase < BOX_ATK_IDLE_PHASE) ? A.idle : (A.atk[0] || A.idle);
        }else{
          // 他は通常どおり攻撃アニメをループ
          img = A.atk[Math.floor(this.animT*ATK_FPS)%Math.max(1,A.atk.length)] || A.idle;
        }

      }else{
        img = A.idle;
      }

      const w=this.width(), h=this.height();
      const flip = this.side<0;
      ctx.save();
      ctx.translate(this.x, this.y);
      if(flip) ctx.scale(-1,1);
      drawImageCentered(ctx, img, 0, -h*0.6, w, h);
      ctx.restore();

      // HPバー
      const hpw = 40, hph=5, x = this.x - hpw/2, y = this.y - h*0.9;
      const rate = Math.max(0,this.hp)/this.maxHp;
      ctx.fillStyle="#000000aa"; ctx.fillRect(x,y,hpw,hph);
      ctx.fillStyle = mixHex("#ef5350","#4caf50", rate);
      ctx.fillRect(x,y,hpw*rate,hph);
      ctx.strokeStyle="#1a263d"; ctx.strokeRect(x+0.5,y+0.5,hpw-1,hph-1);
    }
  }

  function drawImageCentered(ctx,img,cx,cy,w,h){
    if(!img){ ctx.fillStyle="#8886"; ctx.fillRect(cx-w/2, cy-h/2, w, h); return; }
    ctx.drawImage(img, cx-w/2, cy-h/2, w, h);
  }
  function flash(target){ hits.push({x:target.x, y:target.y-28, t:0}); }

  // ====== スポーン ======
  function spawnAlly(kind){
    const def = UNIT_KINDS[kind];
    if(coins < def.cost) return;
    coins -= def.cost;
    allies.push(new Unit(kind, +1));
    pulse(`{ ${def.name} 出撃 }`);
  }
  function spawnEnemy(kind){ enemies.push(new Unit(kind, -1)); }

  // ====== 進行 ======
  function step(dt){
    if(paused) return;
    const now = performance.now();
    if(now - lastCoinTick >= COIN_TICK){ coins += COIN_ADD; lastCoinTick = now; }

    if(!enemyActive && enemyQueue.length>0){ spawnEnemy(enemyQueue.shift().kind); enemyActive = true; }

    for(const u of allies) u.step(dt);
    for(const u of enemies) u.step(dt);

    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].state==="dead") enemies.splice(i,1);
    for(let i=allies.length-1;i>=0;i--) if(allies[i].state==="dead") allies.splice(i,1);

    if(enemyActive && enemies.length===0) enemyActive=false;

    for(let i=hits.length-1;i>=0;i--){ hits[i].t += dt; if(hits[i].t>0.25) hits.splice(i,1); }
  }

  function draw(){
    const g = geom();

    // 背景
    ctx.clearRect(0,0,W,H);
    if(assets.bg){
      const bg = assets.bg;
      const r = Math.max(W/bg.width, H/bg.height);
      const bw = bg.width*r, bh = bg.height*r;
      ctx.drawImage(bg, (W-bw)/2, (H-bh)/2, bw, bh);
    }else{
      ctx.fillStyle="#08111f"; ctx.fillRect(0,0,W,H);
    }

    // フロア帯（下部に固定）
    if(assets.floor){
      const fh = g.groundBandH;
      const y  = g.groundTopY;
      const patternW = assets.floor.width;
      const scale = (fh / assets.floor.height);
      const drawW = patternW * scale;
      for(let x = -((Date.now()/70)%drawW); x<W+drawW; x+=drawW){
        ctx.drawImage(assets.floor, x, y, drawW, fh);
      }
    }else{
      ctx.fillStyle="#2c2c2c"; ctx.fillRect(0,g.groundTopY,W,g.groundBandH);
    }

    // タワー
    function drawTower(t, img){
      const th = Math.min(140, Math.round(H*0.22));
      const tw = Math.round(th * 0.6);
      const flip = t.side<0;
      ctx.save();
      ctx.translate(t.x, g.GROUND_Y);
      if(flip) ctx.scale(-1,1);
      drawImageCentered(ctx, img, 0, -th*0.62, tw, th);
      ctx.restore();
      const hpw = Math.round(W*0.22), hph=7, x=t.x-hpw/2, y=g.GROUND_Y - th*0.85;
      const rate = Math.max(0,t.hp)/1200;
      ctx.fillStyle="#000000aa"; ctx.fillRect(x,y,hpw,hph);
      ctx.fillStyle=mixHex("#ef5350","#4caf50", rate); ctx.fillRect(x,y,hpw*rate,hph);
      ctx.strokeStyle="#1a263d"; ctx.strokeRect(x+0.5,y+0.5,hpw-1,hph-1);
    }
    drawTower(towerL, assets.towerL);
    drawTower(towerR, assets.towerR);

    // ユニット
    const all = [...allies,...enemies].sort((a,b)=>a.x-b.x);
    for(const u of all) u.draw(ctx);

    // ヒット演出
    for(const h of hits){
      const a = Math.max(0, 1 - h.t*4);
      ctx.save(); ctx.globalAlpha = a;
      ctx.fillStyle="#ffd180";
      ctx.beginPath(); ctx.arc(h.x, h.y, 10 + h.t*40, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // ====== ループ ======
  function loop(){
    if(paused) return;
    const now = performance.now();
    let dt = (now - lastTime)/1000; lastTime = now;
    dt = Math.min(dt, 0.05);
    step(dt); draw();
    coinsEl.textContent = coins|0;
    const inst = 1/dt; fpsSmoothed = fpsSmoothed*0.9 + inst*0.1; fpsEl.textContent = Math.round(fpsSmoothed);
    requestAnimationFrame(loop);
  }

  // ====== UI ======
  function pulse(t){
    msgEl.textContent = t; msgEl.style.display="block";
    clearTimeout(pulse._t); pulse._t = setTimeout(()=>{ msgEl.style.display="none"; }, 1000);
  }
  document.getElementById("btnBox").addEventListener("click", ()=>spawnAlly("BOX"));
  document.getElementById("btnFtr").addEventListener("click", ()=>spawnAlly("FTR"));
  document.getElementById("pausePill").addEventListener("click", ()=>{
    paused = !paused;
    document.getElementById("pausePill").textContent = paused ? "▶ Resume" : "⏸ Pause";
    if(!paused){ lastTime = performance.now(); loop(); }
  });

  // ====== 起動 ======
  (async ()=>{
    await loadAll();
    const g = geom();
    towerL.x = g.L_TOWER_X; towerL.y = g.GROUND_Y;
    towerR.x = g.R_TOWER_X; towerR.y = g.GROUND_Y;
    lastCoinTick = performance.now();
    msgEl.style.display="block";
    lastTime = performance.now();
    loop();
  })();

})();
</script>
</body>
</html>
