<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB TD – 弾ヒットで消える対応(フル)</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --app-w: 420px;
    --row-hud: 52px;
    --row-controls: 186px;
    --hud-bg: #0e1118f0;
    --hud-fg: #eaf3ff;
    --hud-accent: #4dd0ff;
    --panel-bg: #0b1424f2;
    --panel-stroke: #1b2a44;
    --panel-shadow: 0 8px 22px rgba(0,0,0,.38);
  }
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;overscroll-behavior:none}
  *{box-sizing:border-box}
  #root{position:fixed;inset:0;display:grid;place-items:center}
  #app{
    width:min(100vw,var(--app-w));
    height:100dvh;
    display:grid;
    grid-template-rows: calc(var(--row-hud) + env(safe-area-inset-top)) 1fr calc(var(--row-controls) + env(safe-area-inset-bottom));
    background:#05080f;
    border:1px solid #0e1522; border-radius:18px; overflow:hidden;
    box-shadow:0 14px 48px rgba(0,0,0,.55);
  }

  header.hud{
    display:flex; align-items:center; gap:6px;
    padding:6px 8px calc(6px + env(safe-area-inset-top)) 8px;
    background:linear-gradient(to bottom,#020409,#0b1220);
    border-bottom:1px solid #0f1b2e;
  }
  .pill{
    background:var(--hud-bg); color:var(--hud-fg);
    border:1px solid #1b2638; border-radius:999px; padding:4px 8px; font-size:13px;
    display:flex; align-items:center; gap:6px;
    box-shadow:0 2px 8px rgba(0,0,0,.25);
  }
  .pill b{color:var(--hud-accent)}
  .spacer{flex:1}
  .tiny{font-size:12px; opacity:.9}
  .clickable{cursor:pointer}

  main.play{position:relative; background:#000;}
  #view{position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated; display:block;}
  .center-msg{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:6px 10px; border-radius:10px; background:#00000099; border:1px solid #24324f;
    font-size:12px; text-align:center; pointer-events:none;
  }

  footer.controls{
    padding:8px 8px calc(10px + env(safe-area-inset-bottom)) 8px;
    background:linear-gradient(to top,#091323,#0b1424cc);
    border-top:1px solid #0f1b2e;
    overflow:auto;
  }
  .grid4{
    height:100%;
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    grid-auto-rows: 1fr;
    gap:8px;
  }
  .card{
    background:var(--panel-bg); color:#e7f1ff;
    border:1px solid var(--panel-stroke); border-radius:12px; padding:8px;
    display:grid; align-content:start; gap:6px; text-align:center;
    box-shadow:var(--panel-shadow);
  }
  .card h3{margin:0; font-size:13px; letter-spacing:.2px}
  .cost{font-size:11px; opacity:.9}
  .btn{
    appearance:none; border:1px solid #2a3751; background:#122034; color:#e9f3ff; border-radius:10px;
    padding:8px 10px; font-weight:700; font-size:13px; cursor:pointer;
    box-shadow:inset 0 0 0 1px #19314e, 0 2px 10px rgba(0,0,0,.25);
  }
  .btn:disabled{opacity:.5; filter:grayscale(.3); cursor:not-allowed}
  .hint{font-size:10px; opacity:.8}
</style>
</head>
<body>
<div id="root">
  <div id="app">
    <header class="hud">
      <div class="pill">💰 <b id="coins">0</b></div>
      <div class="pill tiny">+8 / 3s</div>
      <div class="spacer"></div>
      <div class="pill tiny">FPS: <b id="fps">60</b></div>
      <div class="pill tiny clickable" id="pausePill">⏸ Pause</div>
    </header>

    <main class="play">
      <canvas id="view"></canvas>
      <div class="center-msg" id="msg">下のボタンでユニットを出撃できます</div>
    </main>

    <footer class="controls">
      <div class="grid4">
        <div class="card"><h3>MOB段ボール</h3><div class="cost">コスト <b>50</b> / HP150 / 近接</div><button class="btn" id="btnBox">出撃</button><div class="hint">C1〜C4.png</div></div>
        <div class="card"><h3>MOBファイター</h3><div class="cost">コスト <b>120</b> / HP120 / 近接（速）</div><button class="btn" id="btnFtr">出撃</button><div class="hint">EN1-1〜EN1-5.png</div></div>
        <div class="card"><h3>ワルMOB</h3><div class="cost">コスト <b>30</b> / HP100 / 近接＋短距離弾</div><button class="btn" id="btnEvil">出撃</button><div class="hint">teki1〜3.png, teki7.png</div></div>
        <div class="card"><h3>MOB ウィザード</h3><div class="cost">コスト <b>200</b> / HP200 / 遠距離200px</div><button class="btn" id="btnWiz">出撃</button><div class="hint">MOBM, MOBM2, MOBM3, mahou1.png</div></div>
        <div class="card"><h3>MOBゴレムロボ</h3><div class="cost">コスト <b>100</b> / HP600 / 壁＋短距離投射</div><button class="btn" id="btnGolem">出撃</button><div class="hint">R1〜R5.png</div></div>
        <div class="card"><h3>MOBアイスロボ</h3><div class="cost">コスト <b>200</b> / HP900 / 中距離140px</div><button class="btn" id="btnIce">出撃</button><div class="hint">I1〜I5.png, I8.png</div></div>
        <div class="card"><h3>MOBアイスロボミニ</h3><div class="cost">コスト <b>55</b> / HP160 / 近接（中速）</div><button class="btn" id="btnMini">出撃</button><div class="hint">IC1〜IC3.png</div></div>
        <div class="card"><h3>MOBシールド</h3><div class="cost">コスト <b>110</b> / HP500 / 中距離160px</div><button class="btn" id="btnShield">出撃</button><div class="hint">SL, SL2〜3, SL4〜5, SL8.png</div></div>
        <div class="card"><h3>MOB巨神</h3><div class="cost">コスト <b>300</b> / HP2000 / ボス</div><button class="btn" id="btnGiant">出撃</button><div class="hint">P1,P2,P3,P6,P7,P10.png</div></div>
        <div class="card"><h3>MOBスクリュー</h3><div class="cost">コスト <b>200</b> / HP1500 / 近接（中速）</div><button class="btn" id="btnScrew">出撃</button><div class="hint">B1,B2〜4,B12,B13,B14.png</div></div>
        <div class="card"><h3>MOBウィングヴィラン</h3><div class="cost">コスト <b>260</b> / HP500 / 遠距離100px</div><button class="btn" id="btnWing">出撃</button><div class="hint">1VW.png, DAN2.png（2連弾）</div></div>
      </div>
    </footer>
  </div>
</div>

<script>
(() => {
  /* 敵の出現比率（合計≈1.00）— ウィングは味方専用のため未追加 */
  const ENEMY_WEIGHTS = { BOX:0.34, MINI:0.22, SHIELD:0.12, ICE:0.12, GIANT:0.05, SCREW:0.15 };

  /* 画像パス */
  const IMAGES = {
    bg:"sora.png", floor:"doro.png", towerL:"T1.png", towerR:"T2.png",
    BOX:{idle:"C1.png",walk:["C2.png","C3.png"],atk:"C4.png"},
    FTR:{idle:"EN1-1.png",walk:["EN1-2.png","EN1-3.png"],atk:["EN1-4.png","EN1-5.png"]},
    TEKI:{idle:"teki1.png",walk:["teki1.png","teki2.png"],atk:"teki3.png",proj:"teki7.png"},
    WIZ:{idle:"MOBM.png",walk:["MOBM2.png"],atk:"MOBM3.png"},
    GOLEM:{idle:"R1.png",walk:["R1.png","R2.png","R3.png"],atk:"R4.png",proj:"R5.png"},
    ICE:{idle:"I1.png",walk:["I2.png","I3.png"],atk:"I5.png",charge:"I4.png"},
    MINI:{idle:"IC1.png",walk:["IC2.png"],atk:"IC3.png"},
    SHIELD:{idle:"SL.png",walk:["SL2.png","SL3.png"],atk:["SL4.png","SL5.png"],proj:"SL8.png"},
    GIANT:{idle:"P1.png",walk:["P1.png","P2.png","P3.png"],charge:"P6.png",atk:"P7.png",proj:"P10.png"},
    SCREW:{idle:"B1.png",walk:["B2.png","B3.png","B4.png"],charge:"B12.png",atk:["B13.png","B14.png"]},
    /* 新規：ウィングヴィラン（移動も攻撃も1VW.pngでOK） */
    WING:{idle:"1VW.png",walk:["1VW.png"],atk:"1VW.png"},
    /* 弾画像 */
    PROJ:{
      magic:"mahou1.png", short:"teki7.png", golem:"R5.png", ice:"I8.png", shield:"SL8.png", giant:"P10.png",
      wing:"DAN2.png"
    }
  };

  /* DOM */
  const canvas=document.getElementById("view"), ctx=canvas.getContext("2d");
  const playEl=document.querySelector("main.play");
  const coinsEl=document.getElementById("coins"), fpsEl=document.getElementById("fps"), msgEl=document.getElementById("msg");

  /* サイズ */
  let W=420, H=560;
  function measure(){ const r=playEl.getBoundingClientRect(); W=Math.max(320, r.width|0); H=Math.max(360, r.height|0); canvas.width=W; canvas.height=H; }
  measure(); addEventListener("resize", measure);

  /* 幾何 */
  function geom(){
    const groundBandH=Math.round(H*0.22), groundTopY=H-groundBandH;
    const GROUND_Y=groundTopY+Math.round(groundBandH*0.85);
    const L_TOWER_X=Math.round(W*0.09), R_TOWER_X=Math.round(W*0.91);
    return {groundBandH,groundTopY,GROUND_Y,L_TOWER_X,R_TOWER_X};
  }

  /* パラメータ */
  const COIN_TICK=3000, COIN_ADD=8;
  const PX_PER_SPEED=18, WALK_FPS=6, ATK_IDLE_PHASE=0.18, ATK_TOTAL=0.36;
  const MELEE_RANGE=26, RANGE_MEDIUM=140, RANGE_MEDIUM_PLUS=160;
  const PROJ_SPEED_WIZ=230, PROJ_SPEED_SHORT=200, PROJ_SPEED_GOLEM=180, PROJ_SPEED_ICE=200, PROJ_SPEED_SHIELD=210, PROJ_SPEED_GIANT=240, PROJ_SPEED_WING=240;
  const GOLEM_BLOCK_DIST=26, GOLEM_SLOW_RATE=0.25;
  const ICE_CHARGE_TIME=0.50, ICE_CHARGE_MIN_S=0.18, ICE_CHARGE_MAX_S=1.0;
  const HOP_AMP_MINI=6;
  const GIANT_CHARGE_TIME=0.60, GIANT_HOP_AMP=14, GIANT_BIGJUMP_AMP=28, GIANT_BIGJUMP_PERIOD=3.0, GIANT_PROJ_TRAVEL=110;

  /* ユニット定義（射程内全員ヒットは共通）*/
  const UNIT_KINDS = {
    BOX:{name:"MOB段ボール",hp:150,atk:20,atkInt:1.0,speed:3,cost:50,key:"BOX",rangePx:MELEE_RANGE,scale:0.6,hover:false,hop:false,proj:null},
    FTR:{name:"MOBファイター",hp:120,atk:30,atkInt:0.7,speed:5,cost:120,key:"FTR",rangePx:MELEE_RANGE,scale:0.6,hover:false,hop:false,proj:null},
    TEKI:{name:"ワルMOB",hp:100,atk:15,atkInt:1.0,speed:3,cost:30,key:"TEKI",rangePx:80,scale:0.6,hover:false,hop:false,
      proj:{imgKey:"short",speed:PROJ_SPEED_SHORT,maxTravel:120,wobble:true}},
    WIZ:{name:"MOB ウィザード",hp:200,atk:80,atkInt:2.6,speed:2,cost:200,key:"WIZ",rangePx:200,scale:0.66,hover:true,hop:false,
      proj:{imgKey:"magic",speed:PROJ_SPEED_WIZ,maxTravel:null,wobble:false}},
    GOLEM:{name:"MOBゴレムロボ",hp:600,atk:10,atkInt:1.5,speed:1,cost:100,key:"GOLEM",rangePx:MELEE_RANGE,scale:0.75,hover:false,hop:false,
      proj:{imgKey:"golem",speed:PROJ_SPEED_GOLEM,maxTravel:90,wobble:false}},
    ICE:{name:"MOBアイスロボ",hp:900,atk:100,atkInt:2.5,speed:1,cost:200,key:"ICE",rangePx:RANGE_MEDIUM,scale:0.75,hover:false,hop:true,
      proj:{imgKey:"ice",speed:PROJ_SPEED_ICE,maxTravel:null,wobble:false,delayed:true,delaySec:ICE_CHARGE_TIME}},
    MINI:{name:"MOBアイスロボミニ",hp:160,atk:23,atkInt:1.0,speed:2,cost:55,key:"MINI",rangePx:MELEE_RANGE,scale:0.58,hover:false,hop:true,proj:null,sway:true},
    SHIELD:{name:"MOBシールド",hp:500,atk:28,atkInt:1.6,speed:1,cost:110,key:"SHIELD",rangePx:RANGE_MEDIUM_PLUS,scale:0.72,hover:false,hop:false,
      proj:{imgKey:"shield",speed:PROJ_SPEED_SHIELD,maxTravel:null,wobble:false,delayed:true,delaySec:0.20}},
    GIANT:{name:"MOB巨神",hp:2000,atk:100,atkInt:2.5,speed:1,cost:300,key:"GIANT",rangePx:MELEE_RANGE,scale:1.25,hover:false,hop:true,
      proj:{imgKey:"giant",speed:PROJ_SPEED_GIANT,maxTravel:GIANT_PROJ_TRAVEL,wobble:false,delayed:true,delaySec:GIANT_CHARGE_TIME},giant:true},
    SCREW:{name:"MOBスクリュー",hp:1500,atk:120,atkInt:1.7,speed:2,cost:200,key:"SCREW",rangePx:MELEE_RANGE,scale:0.72,hover:false,hop:false,
      proj:null, atkDelaySec:0.30, shakeOnCharge:true},
    /* 新規：MOBウィングヴィラン（遠隔100px・弾2連・高速上下スイング） */
    WING:{name:"MOBウィングヴィラン",hp:500,atk:50,atkInt:2.2,speed:2,cost:260,key:"WING",rangePx:100,scale:0.72,hover:true,hop:false,
      proj:{imgKey:"wing",speed:PROJ_SPEED_WING,maxTravel:null,wobble:true,wobbleAmp:12,wobbleFreq:0.18,count:2,offsetYStep:7,phaseAlt:true}}
  };

  /* 画像ローディング */
  function loadImage(src){ return new Promise(res=>{ const img=new Image(); img.src=src; img.onload=()=>res(img); img.onerror=()=>res(null); }); }
  const assets={};
  async function loadAll(){
    assets.bg=await loadImage(IMAGES.bg); assets.floor=await loadImage(IMAGES.floor);
    assets.towerL=await loadImage(IMAGES.towerL); assets.towerR=await loadImage(IMAGES.towerR);
    for(const key of Object.keys(UNIT_KINDS)){
      const set=IMAGES[key]; assets[key]={idle:null,walk:[],atk:[],charge:null};
      assets[key].idle=await loadImage(set.idle);
      for(const s of (Array.isArray(set.walk)?set.walk:[set.walk])) assets[key].walk.push(await loadImage(s));
      for(const s of (Array.isArray(set.atk)?set.atk:[set.atk])) assets[key].atk.push(await loadImage(s));
      if(set.charge) assets[key].charge=await loadImage(set.charge);
    }
    assets.PROJ={}; for(const k of Object.keys(IMAGES.PROJ)) assets.PROJ[k]=await loadImage(IMAGES.PROJ[k]);
  }

  /* 状態 */
  let coins=500, lastCoinTick=0, paused=false, lastTime=performance.now(), fpsSmoothed=60;
  const towerL={x:0,y:0,hp:1200,side:+1}, towerR={x:0,y:0,hp:1200,side:-1};
  const allies=[], enemies=[], projectiles=[], hits=[];
  let enemyActive=false;

  function pickEnemyKind(){
    const r=Math.random(); let acc=0;
    for(const k of ["BOX","MINI","SHIELD","ICE","GIANT","SCREW"]){ acc+=(ENEMY_WEIGHTS[k]||0); if(r<=acc) return k; }
    return "BOX";
  }

  /* ユーティリティ */
  function mixHex(a,b,t){function toRGB(h){const n=parseInt(h.slice(1),16);return{r:(n>>16)&255,g:(n>>8)&255,b:n&255}}function toHex(r,g,b){return"#"+[r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("")}
    const A=toRGB(a),B=toRGB(b); return toHex(Math.round(A.r*(1-t)+B.r*t),Math.round(A.g*(1-t)+B.g*t),Math.round(A.b*(1-t)+B.b*t));}
  function drawImageCentered(ctx,img,cx,cy,w,h){ if(!img){ctx.fillStyle="#8886";ctx.fillRect(cx-w/2,cy-h/2,w,h);return;} ctx.drawImage(img,cx-w/2,cy-h/2,w,h); }
  function flash(target){ hits.push({ref:target, x:target.x, y:target.y-28, t:0}); }

  /* 投射物（見た目のみ／衝突で消滅） */
  class Projectile{
    constructor({x,y,side,imgKey,speed,maxTravel=null,wobble=false,wobbleAmp=4,wobbleFreq=0.08,wobblePhase=0}){
      this.x=x; this.y=y; this.side=side; this.img=assets.PROJ[imgKey];
      this.angle=0; this.dead=false; this.speed=speed||220; this.startX=x; this.maxTravel=maxTravel;
      this.wobble=wobble; this._wobAmp=wobbleAmp; this._wobFreq=wobbleFreq; this._phase=wobblePhase; this._wobY=0;
      this.travel=0; this.armDist=8; /* 近距離で即消え防止 */
    }
    step(dt){
      const dx=(this.side>0?1:-1)*this.speed*dt;
      this.x += dx; this.travel += Math.abs(dx);
      this.angle += (this.speed>=230?10:6)*dt;
      this._wobY = this.wobble ? Math.sin(this.x*this._wobFreq + this._phase)*this._wobAmp : 0;

      if(this.x<-40 || this.x>W+40) this.dead=true;
      if(this.maxTravel!=null && Math.abs(this.x - this.startX) >= this.maxTravel) this.dead=true;
      if(this.dead) return;

      /* 見た目の衝突判定：敵ユニット → タワー */
      if(this.travel >= this.armDist){
        const visY = (this.y - 28) + (this._wobY||0);
        const foes = this.side>0 ? enemies : allies;
        const hitXPadBase = 18;
        for(const f of foes){
          if(f.state==="dead") continue;
          const fx = f.x;
          const fy = f.y - f.height()*0.6;
          const xClose = Math.abs(this.x - fx) <= Math.max(hitXPadBase, f.width()*0.38);
          const yClose = Math.abs(visY - fy) <= (f.height()*0.55);
          if(xClose && yClose){ this.dead = true; break; }
        }
        if(!this.dead){
          const foeT = this.side>0 ? towerR : towerL;
          const towerHitPad = 12;
          if(this.side>0 ? (this.x >= foeT.x - towerHitPad) : (this.x <= foeT.x + towerHitPad)){
            this.dead = true;
          }
        }
      }
    }
    draw(ctx){ const sz=30; ctx.save(); ctx.translate(this.x, (this.y-28)+(this._wobY||0)); ctx.rotate(this.angle); drawImageCentered(ctx,this.img,0,0,sz,sz); ctx.restore(); }
  }

  /* ユニット */
  class Unit{
    constructor(kindKey, side){
      const def=UNIT_KINDS[kindKey]; this.kind=kindKey; this.side=side; const g=geom();
      this.x= side>0 ? (g.L_TOWER_X+28) : (g.R_TOWER_X-28); this.y=g.GROUND_Y;
      this.maxHp=def.hp; this.hp=def.hp; this.atk=def.atk; this.atkInt=def.atkInt; this.cool=0;
      this.speed=def.speed*PX_PER_SPEED; this.scale=def.scale; this.rangePx=def.rangePx;
      this.hover=!!def.hover; this.hop=!!def.hop; this.sway=!!def.sway; this.proj=def.proj; this.giant=!!def.giant;
      this.atkDelaySec=def.atkDelaySec||0; this.shakeOnCharge=!!def.shakeOnCharge;
      this.state="walk"; this.animT=0; this.firePending=false; this.fireDelaySec=0;
      this.knockIdx=0; this.knockT=0; this.knockDur=0.35; this.knockDist=32; this.knockActive=false;
      this.knockHeights=[16,18,20];
      this._lastDrawOffsets={hoverY:0, hopY:0, swayX:0, knockY:0};
    }
    width(){return 64*this.scale;}
    height(){return 64*this.scale;}

    getThreshold(){ return [0.7,0.4,0.1][this.knockIdx] ?? null; }

    hurt(dmg){
      if(this.state==="dead") return;
      const prev=this.hp; this.hp=Math.max(0,this.hp-dmg); flash(this);
      const thr=this.getThreshold();
      if(thr!=null && prev>=this.maxHp*thr && this.hp<this.maxHp*thr){
        this.knockActive=true; this.knockT=0; this.state="knock";
      }
      if(this.hp<=0) this.state="dead";
    }

    hasFrontTarget(){
      const foes=this.side>0?enemies:allies;
      for(const f of foes){
        if(f.state==="dead") continue;
        const dx=(f.x - this.x)*this.side;
        if(dx>=0 && dx<=this.rangePx) return true;
      }
      const foeTower=this.side>0?towerR:towerL;
      const dxT=(foeTower.x - this.x)*this.side;
      return (dxT>=0 && dxT<=this.rangePx);
    }

    /* 射程内“前方”の全対象へ一括ダメージ */
    sweepDamage(){
      const foes=this.side>0?enemies:allies;
      for(const f of foes){
        if(f.state==="dead") continue;
        const dx=(f.x - this.x)*this.side;
        if(dx>=0 && dx<=this.rangePx){ f.hurt(this.atk); }
      }
      const foeTower=this.side>0?towerR:towerL;
      const dxT=(foeTower.x - this.x)*this.side;
      if(dxT>=0 && dxT<=this.rangePx){ foeTower.hp -= this.atk; }
    }

    static slowFactorNearGolem(unit){
      if(unit.kind==="GOLEM") return 1.0;
      const foes=unit.side>0?enemies:allies;
      for(const f of foes){
        if(f.state==="dead" || f.kind!=="GOLEM") continue;
        const dx=f.x - unit.x;
        if(unit.side>0 && dx>=0 && dx<=GOLEM_BLOCK_DIST) return GOLEM_SLOW_RATE;
        if(unit.side<0 && dx<=0 && -dx<=GOLEM_BLOCK_DIST) return GOLEM_SLOW_RATE;
      }
      return 1.0;
    }

    /* 弾の発射（演出）— proj.count/offsetYStep/phaseAltに対応 */
    emitProjectiles(){
      const p=this.proj; if(!p) return;
      const count=p.count||1;
      for(let i=0;i<count;i++){
        const sign = (i%2===0)?+1:-1;
        const offY = (count===1)?0 : (p.offsetYStep||6)*sign;
        const phase = p.phaseAlt ? (i%2===0?0:Math.PI) : 0;
        projectiles.push(new Projectile({
          x:this.x + (this.side>0?+14:-14),
          y:this.y + offY,
          side:this.side,
          imgKey:p.imgKey,
          speed:p.speed||220,
          maxTravel:p.maxTravel ?? null,
          wobble:!!p.wobble,
          wobbleAmp:p.wobbleAmp||4,
          wobbleFreq:p.wobbleFreq||0.08,
          wobblePhase:phase
        }));
      }
    }

    step(dt){
      if(this.state==="dead") return;

      // ノックバック中
      if(this.state==="knock" && this.knockActive){
        this.knockT += dt;
        const kRate=Math.min(1,this.knockT/this.knockDur);
        const backSpeed=(this.knockDist/this.knockDur);
        this.x -= this.side*backSpeed*dt;
        this._lastDrawOffsets.knockY = -Math.sin(Math.PI*kRate)*this.knockHeights[Math.min(this.knockIdx, this.knockHeights.length-1)];
        const g=geom(), limitL=g.L_TOWER_X+14, limitR=g.R_TOWER_X-14;
        if(this.side>0 && this.x<limitL) this.x=limitL;
        if(this.side<0 && this.x>limitR) this.x=limitR;
        if(kRate>=1){ this.knockActive=false; this._lastDrawOffsets.knockY=0; this.knockIdx++; this.state="walk"; }
        this.animT += dt; this.cool = Math.max(0, this.cool - dt);
        return;
      }

      this.cool = Math.max(0, this.cool - dt);
      const inRange = this.hasFrontTarget();

      // 遅延攻撃（ICE/SHIELD/GIANT/SCREW の溜め完了時点）
      if(this.state==="atk" && this.firePending && this.animT >= this.fireDelaySec){
        if(this.proj){ this.emitProjectiles(); }
        this.sweepDamage();
        this.firePending=false;
      }

      if(inRange){
        if(this.cool===0){
          this.state="atk"; this.animT=0;
          const isDelayed = (this.proj && this.proj.delayed) || (this.atkDelaySec>0);
          if(isDelayed){
            this.firePending=true;
            this.fireDelaySec = (this.proj && this.proj.delayed) ? (this.proj.delaySec||0.2) : this.atkDelaySec;
          }else{
            if(this.proj){ this.emitProjectiles(); }
            this.sweepDamage();
          }
          this.cool=this.atkInt;
        }
      }else{
        this.state="walk";
        let spd=this.speed*Unit.slowFactorNearGolem(this);
        this.x += this.side*spd*dt;
        const g=geom(); const limitL=g.L_TOWER_X+18, limitR=g.R_TOWER_X-18;
        if(this.side>0 && this.x>limitR) this.x=limitR; if(this.side<0 && this.x<limitL) this.x=limitL;
      }

      if(this.hp<=0) this.state="dead";
      this.animT += dt;
    }

    draw(ctx){
      if(this.state==="dead") return;
      const def=UNIT_KINDS[this.kind], A=assets[def.key]; let img=null;

      const tNow=performance.now()/1000;
      const hoverY = this.hover ? Math.sin(tNow + this.x*0.01)*6 : 0;

      let hopY=0, useHighJump=false;
      if(this.hop && this.state==="walk"){
        if(this.giant){
          const phase=(tNow % GIANT_BIGJUMP_PERIOD)/GIANT_BIGJUMP_PERIOD; useHighJump = (phase>0.75);
          const amp = useHighJump ? GIANT_BIGJUMP_AMP : GIANT_HOP_AMP;
          hopY = -Math.abs(Math.sin(tNow*3 + this.x*0.02))*amp;
        }else{
          hopY = -Math.abs(Math.sin(tNow*3 + this.x*0.02))*(this.kind==="ICE"?8:HOP_AMP_MINI);
        }
      }
      const swayX = (this.sway && this.state==="walk") ? Math.sin(tNow*2.2 + this.x*0.05)*3 : 0;

      if(this.state==="walk"){
        if(this.giant && useHighJump){ img = A.walk[2] || A.idle; }
        else { img = A.walk[Math.floor(this.animT*WALK_FPS)%Math.max(1,A.walk.length)] || A.idle; }
      }else if(this.state==="atk"){
        if(this.giant){ img = (this.animT<GIANT_CHARGE_TIME) ? (A.charge||A.idle) : (A.atk[0]||A.idle); }
        else if(this.kind==="ICE"){ img = (this.animT<ICE_CHARGE_TIME) ? (A.charge||A.idle) : (A.atk[0]||A.idle); }
        else if(this.kind==="SCREW"){
          if(this.animT < (this.atkDelaySec||0.3)){ img = A.charge || A.idle; }
          else{
            const rest = Math.max(0, (this.animT - (this.atkDelaySec||0.3)));
            const idx = Math.min(1, Math.floor(rest / ((ATK_TOTAL-ATK_IDLE_PHASE)/2)));
            img = A.atk[idx] || A.atk[0] || A.idle;
          }
        }else{
          const phase=this.animT%ATK_TOTAL;
          if(phase<ATK_IDLE_PHASE) img=A.idle;
          else { const len=Math.max(1,A.atk.length); const idx=Math.floor((phase-ATK_IDLE_PHASE)/(ATK_TOTAL-ATK_IDLE_PHASE)*len)%len; img=A.atk[idx]||A.idle; }
        }
      }else if(this.state==="knock"){ img = A.idle; }
      else { img = A.idle; }

      const w=this.width(), h=this.height(), flip=this.side<0;

      // 揺れ：巨神 or スクリュー溜め中だけ
      let shakeX=0, shakeY=0;
      if( (this.giant && this.state==="atk" && this.animT<GIANT_CHARGE_TIME) ||
          (this.kind==="SCREW" && this.state==="atk" && this.animT<(this.atkDelaySec||0.3) && this.shakeOnCharge) ){
        const s=2.8; shakeX=(Math.random()*2-1)*s; shakeY=(Math.random()*2-1)*s;
      }

      this._lastDrawOffsets.hoverY=hoverY; this._lastDrawOffsets.hopY=hopY;

      ctx.save();
      ctx.translate(this.x + swayX + shakeX, this.y + hoverY + hopY + (this._lastDrawOffsets.knockY||0) + shakeY);
      if(flip) ctx.scale(-1,1);
      drawImageCentered(ctx,img,0,-h*0.6,w,h);

      // ICE/巨神の溜め演出
      if(this.kind==="ICE" && this.state==="atk" && this.animT<ICE_CHARGE_TIME){
        const p=Math.min(1,this.animT/ICE_CHARGE_TIME), s=ICE_CHARGE_MIN_S*(1-p)+ICE_CHARGE_MAX_S*p;
        const orb=assets.PROJ.ice; const offX=14, offY=-h*0.68; drawImageCentered(ctx, orb, (flip?-offX:offX), offY, 24*s, 24*s);
      }
      if(this.giant && this.state==="atk" && this.animT<GIANT_CHARGE_TIME){
        const p=(Math.sin(tNow*12)+1)/2, s=0.4+p*0.3; const orb=assets.PROJ.giant; const offX=18, offY=-h*0.65;
        drawImageCentered(ctx, orb, (flip?-offX:offX), offY, 26*s, 26*s);
      }

      ctx.restore();

      // HPバー（頭上）
      const offsetsY=this._lastDrawOffsets.hoverY + this._lastDrawOffsets.hopY + (this._lastDrawOffsets.knockY||0);
      const hpw=this.giant?72:50, hph=this.giant?7:6;
      const barX=this.x - hpw/2, barY=(this.y + offsetsY) - h*1.18;
      const rate=Math.max(0,this.hp)/this.maxHp;
      ctx.fillStyle="#000000aa"; ctx.fillRect(barX,barY,hpw,hph);
      ctx.fillStyle=mixHex("#ef5350","#4caf50", rate); ctx.fillRect(barX,barY,hpw*rate,hph);
      ctx.strokeStyle="#1a263d"; ctx.strokeRect(barX+0.5,barY+0.5,hpw-1,hph-1);
    }
  }

  /* スポーン */
  function spawnAlly(kind){ const def=UNIT_KINDS[kind]; if(coins<def.cost) return; coins-=def.cost; allies.push(new Unit(kind,+1)); pulse(`{ ${def.name} 出撃 }`); }
  function spawnEnemy(kind){ enemies.push(new Unit(kind,-1)); }

  /* 進行 */
  function step(dt){
    if(paused) return;
    const now=performance.now(); if(now-lastCoinTick>=COIN_TICK){ coins+=COIN_ADD; lastCoinTick=now; }

    if(!enemyActive){ spawnEnemy(pickEnemyKind()); enemyActive=true; }

    for(const u of allies) u.step(dt);
    for(const u of enemies) u.step(dt);

    for(const p of projectiles) p.step(dt);
    for(let i=projectiles.length-1;i>=0;i--) if(projectiles[i].dead) projectiles.splice(i,1);

    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].state==="dead") enemies.splice(i,1);
    for(let i=allies.length-1;i>=0;i--) if(allies[i].state==="dead") allies.splice(i,1);
    if(enemyActive && enemies.length===0) enemyActive=false;

    for(let i=hits.length-1;i>=0;i--){
      const h=hits[i]; h.t+=dt;
      if(h.ref && h.ref.state!=="dead"){ h.x=h.ref.x; h.y=h.ref.y-28; }
      if(h.t>0.25) hits.splice(i,1);
    }
  }

  /* 描画 */
  function draw(){
    const g=geom();
    ctx.clearRect(0,0,W,H);
    if(assets.bg){ const r=Math.max(W/assets.bg.width, H/assets.bg.height); const bw=assets.bg.width*r, bh=assets.bg.height*r;
      ctx.drawImage(assets.bg, (W-bw)/2, (H-bh)/2, bw, bh);
    }else{ ctx.fillStyle="#08111f"; ctx.fillRect(0,0,W,H); }

    if(assets.floor){
      const fh=g.groundBandH, y=g.groundTopY, patternW=assets.floor.width, scale=(fh/assets.floor.height), drawW=patternW*scale;
      for(let x= -((Date.now()/70)%drawW); x<W+drawW; x+=drawW){ ctx.drawImage(assets.floor, x, y, drawW, fh); }
    }else{ ctx.fillStyle="#2c2c2c"; ctx.fillRect(0,g.groundTopY,W,g.groundBandH); }

    function drawTower(t, img){
      const th=Math.min(140, Math.round(H*0.22)), tw=Math.round(th*0.6), flip=t.side<0;
      ctx.save(); ctx.translate(t.x, g.GROUND_Y); if(flip) ctx.scale(-1,1); drawImageCentered(ctx,img,0,-th*0.62,tw,th); ctx.restore();
      const hpw=Math.round(W*0.22), hph=7, x=t.x-hpw/2, y=g.GROUND_Y - th*0.92;
      const rate=Math.max(0,t.hp)/1200; ctx.fillStyle="#000000aa"; ctx.fillRect(x,y,hpw,hph);
      ctx.fillStyle=mixHex("#ef5350","#4caf50", rate); ctx.fillRect(x,y,hpw*rate,hph); ctx.strokeStyle="#1a263d"; ctx.strokeRect(x+0.5,y+0.5,hpw-1,hph-1);
    }
    drawTower(towerL, assets.towerL); drawTower(towerR, assets.towerR);

    const all=[...allies,...enemies].sort((a,b)=>a.x-b.x);
    for(const u of all) u.draw(ctx);

    for(const p of projectiles) p.draw(ctx);

    for(const h of hits){
      const a=Math.max(0,1 - h.t*4); ctx.save(); ctx.globalAlpha=a;
      ctx.fillStyle="#ffd180"; ctx.beginPath(); ctx.arc(h.x, h.y, 10 + h.t*40, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
  }

  /* ループ */
  function loop(){
    if(paused) return;
    const now=performance.now(); let dt=(now-lastTime)/1000; lastTime=now; dt=Math.min(dt,0.05);
    step(dt); draw();
    coinsEl.textContent = coins|0;
    const inst=1/dt; fpsSmoothed=fpsSmoothed*0.9 + inst*0.1; fpsEl.textContent=Math.round(fpsSmoothed);
    requestAnimationFrame(loop);
  }

  /* UI */
  function pulse(t){ msgEl.textContent=t; msgEl.style.display="block"; clearTimeout(pulse._t); pulse._t=setTimeout(()=>{msgEl.style.display="none";}, 1000); }
  document.getElementById("btnBox").addEventListener("click", ()=>spawnAlly("BOX"));
  document.getElementById("btnFtr").addEventListener("click", ()=>spawnAlly("FTR"));
  document.getElementById("btnEvil").addEventListener("click", ()=>spawnAlly("TEKI"));
  document.getElementById("btnWiz").addEventListener("click", ()=>spawnAlly("WIZ"));
  document.getElementById("btnGolem").addEventListener("click", ()=>spawnAlly("GOLEM"));
  document.getElementById("btnIce").addEventListener("click", ()=>spawnAlly("ICE"));
  document.getElementById("btnMini").addEventListener("click", ()=>spawnAlly("MINI"));
  document.getElementById("btnShield").addEventListener("click", ()=>spawnAlly("SHIELD"));
  document.getElementById("btnGiant").addEventListener("click", ()=>spawnAlly("GIANT"));
  document.getElementById("btnScrew").addEventListener("click", ()=>spawnAlly("SCREW"));
  document.getElementById("btnWing").addEventListener("click", ()=>spawnAlly("WING"));
  document.getElementById("pausePill").addEventListener("click", ()=>{
    paused=!paused; document.getElementById("pausePill").textContent = paused ? "▶ Resume" : "⏸ Pause";
    if(!paused){ lastTime=performance.now(); loop(); }
  });

  /* 起動 */
  (async ()=>{
    await loadAll();
    const g=geom(); towerL.x=g.L_TOWER_X; towerL.y=g.GROUND_Y; towerR.x=g.R_TOWER_X; towerR.y=g.GROUND_Y;
    lastCoinTick=performance.now(); msgEl.style.display="block"; lastTime=performance.now(); loop();
  })();
})();
</script>
</body>
</html>
