<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB TD – アイスロボミニ＆シールド追加</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --app-w: 420px;
    --row-hud: 52px;
    --row-controls: 186px; /* 4列×2段が入る高さ */
    --hud-bg: #0e1118f0;
    --hud-fg: #eaf3ff;
    --hud-accent: #4dd0ff;
    --panel-bg: #0b1424f2;
    --panel-stroke: #1b2a44;
    --panel-shadow: 0 8px 22px rgba(0,0,0,.38);
  }
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;overscroll-behavior:none}
  *{box-sizing:border-box}
  #root{position:fixed;inset:0;display:grid;place-items:center}
  #app{
    width:min(100vw,var(--app-w));
    height:100dvh;
    display:grid;
    grid-template-rows: calc(var(--row-hud) + env(safe-area-inset-top)) 1fr calc(var(--row-controls) + env(safe-area-inset-bottom));
    background:#05080f;
    border:1px solid #0e1522; border-radius:18px; overflow:hidden;
    box-shadow:0 14px 48px rgba(0,0,0,.55);
  }

  header.hud{
    display:flex; align-items:center; gap:6px;
    padding:6px 8px calc(6px + env(safe-area-inset-top)) 8px;
    background:linear-gradient(to bottom,#020409,#0b1220);
    border-bottom:1px solid #0f1b2e;
  }
  .pill{
    background:var(--hud-bg); color:var(--hud-fg);
    border:1px solid #1b2638; border-radius:999px; padding:4px 8px; font-size:13px;
    display:flex; align-items:center; gap:6px;
    box-shadow:0 2px 8px rgba(0,0,0,.25);
  }
  .pill b{color:var(--hud-accent)}
  .spacer{flex:1}
  .tiny{font-size:12px; opacity:.9}
  .clickable{cursor:pointer}

  main.play{position:relative; background:#000;}
  #view{position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated; display:block;}
  .center-msg{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:6px 10px; border-radius:10px; background:#00000099; border:1px solid #24324f;
    font-size:12px; text-align:center; pointer-events:none;
  }

  footer.controls{
    padding:8px 8px calc(10px + env(safe-area-inset-bottom)) 8px;
    background:linear-gradient(to top,#091323,#0b1424cc);
    border-top:1px solid #0f1b2e;
    overflow:auto;
  }
  .grid4{
    height:100%;
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    grid-auto-rows: 1fr;
    gap:8px;
  }
  .card{
    background:var(--panel-bg); color:#e7f1ff;
    border:1px solid var(--panel-stroke); border-radius:12px; padding:8px;
    display:grid; align-content:start; gap:6px; text-align:center;
    box-shadow:var(--panel-shadow);
  }
  .card h3{margin:0; font-size:13px; letter-spacing:.2px}
  .cost{font-size:11px; opacity:.9}
  .btn{
    appearance:none; border:1px solid #2a3751; background:#122034; color:#e9f3ff; border-radius:10px;
    padding:8px 10px; font-weight:700; font-size:13px; cursor:pointer;
    box-shadow:inset 0 0 0 1px #19314e, 0 2px 10px rgba(0,0,0,.25);
  }
  .btn:disabled{opacity:.5; filter:grayscale(.3); cursor:not-allowed}
  .hint{font-size:10px; opacity:.8}
</style>
</head>
<body>
<div id="root">
  <div id="app">
    <header class="hud">
      <div class="pill">💰 <b id="coins">0</b></div>
      <div class="pill tiny">+8 / 3s</div>
      <div class="spacer"></div>
      <div class="pill tiny">FPS: <b id="fps">60</b></div>
      <div class="pill tiny clickable" id="pausePill">⏸ Pause</div>
    </header>

    <main class="play">
      <canvas id="view"></canvas>
      <div class="center-msg" id="msg">下のボタンでユニットを出撃できます</div>
    </main>

    <footer class="controls">
      <div class="grid4">
        <div class="card">
          <h3>MOB段ボール</h3>
          <div class="cost">コスト <b>50</b> / HP150 / 近接</div>
          <button class="btn" id="btnBox">出撃</button>
          <div class="hint">C1〜C4.png</div>
        </div>
        <div class="card">
          <h3>MOBファイター</h3>
          <div class="cost">コスト <b>120</b> / HP120 / 近接（速）</div>
          <button class="btn" id="btnFtr">出撃</button>
          <div class="hint">EN1-1〜EN1-5.png</div>
        </div>
        <div class="card">
          <h3>ワルMOB</h3>
          <div class="cost">コスト <b>30</b> / HP100 / 近接＋短距離弾</div>
          <button class="btn" id="btnEvil">出撃</button>
          <div class="hint">teki1〜3.png, teki7.png</div>
        </div>
        <div class="card">
          <h3>MOB ウィザード</h3>
          <div class="cost">コスト <b>200</b> / HP200 / 遠距離200px</div>
          <button class="btn" id="btnWiz">出撃</button>
          <div class="hint">MOBM, MOBM2, MOBM3, mahou1.png</div>
        </div>
        <div class="card">
          <h3>MOBゴレムロボ</h3>
          <div class="cost">コスト <b>100</b> / HP600 / 壁＋短距離投射</div>
          <button class="btn" id="btnGolem">出撃</button>
          <div class="hint">R1〜R5.png</div>
        </div>
        <div class="card">
          <h3>MOBアイスロボ</h3>
          <div class="cost">コスト <b>200</b> / HP900 / 中距離140px</div>
          <button class="btn" id="btnIce">出撃</button>
          <div class="hint">I1〜I5.png, I8.png</div>
        </div>
        <div class="card">
          <h3>MOBアイスロボミニ</h3>
          <div class="cost">コスト <b>55</b> / HP160 / 近接（中速）</div>
          <button class="btn" id="btnMini">出撃</button>
          <div class="hint">IC1〜IC3.png</div>
        </div>
        <div class="card">
          <h3>MOBシールド</h3>
          <div class="cost">コスト <b>110</b> / HP500 / 中距離160px</div>
          <button class="btn" id="btnShield">出撃</button>
          <div class="hint">SL, SL2〜3, SL4〜5, SL8.png</div>
        </div>
      </div>
    </footer>
  </div>
</div>

<script>
(() => {
  /*======================
    敵の出現ウェイト（合計=1）
    ※必要に応じて調整してください
  ======================*/
  const ENEMY_WEIGHTS = {
    BOX: 0.45,
    MINI: 0.28,
    SHIELD: 0.15,
    ICE: 0.12   // アイスロボは低頻度のまま
  };

  // ====== 画像パス（同フォルダ） ======
  const IMAGES = {
    bg: "sora.png",
    floor: "doro.png",
    towerL: "T1.png",
    towerR: "T2.png",

    BOX:    { idle:"C1.png",    walk:["C2.png","C3.png"],          atk:"C4.png" },
    FTR:    { idle:"EN1-1.png", walk:["EN1-2.png","EN1-3.png"],     atk:["EN1-4.png","EN1-5.png"] },
    TEKI:   { idle:"teki1.png", walk:["teki1.png","teki2.png"],     atk:"teki3.png", proj:"teki7.png" },
    WIZ:    { idle:"MOBM.png",  walk:["MOBM2.png"],                 atk:"MOBM3.png" },
    GOLEM:  { idle:"R1.png",    walk:["R1.png","R2.png","R3.png"],  atk:"R4.png", proj:"R5.png" },
    ICE:    { idle:"I1.png",    walk:["I2.png","I3.png"],           atk:"I5.png",  charge:"I4.png" },
    MINI:   { idle:"IC1.png",   walk:["IC2.png"],                   atk:"IC3.png" },
    SHIELD: { idle:"SL.png",    walk:["SL2.png","SL3.png"],         atk:["SL4.png","SL5.png"], proj:"SL8.png" },

    PROJ: { magic:"mahou1.png", short:"teki7.png", golem:"R5.png", ice:"I8.png", shield:"SL8.png" }
  };

  // ====== DOM ======
  const canvas = document.getElementById("view");
  const ctx = canvas.getContext("2d");
  const playEl = document.querySelector("main.play");
  const coinsEl = document.getElementById("coins");
  const fpsEl = document.getElementById("fps");
  const msgEl = document.getElementById("msg");

  // ====== キャンバスサイズ ======
  let W = 420, H = 560;
  function measure(){
    const r = playEl.getBoundingClientRect();
    W = Math.max(320, Math.round(r.width));
    H = Math.max(360, Math.round(r.height));
    canvas.width = W;
    canvas.height = H;
  }
  measure();
  addEventListener("resize", measure);

  // ====== 幾何（フロアは下部固定） ======
  function geom(){
    const groundBandH = Math.round(H * 0.22);
    const groundTopY  = H - groundBandH;
    const GROUND_Y    = groundTopY + Math.round(groundBandH*0.85);
    const L_TOWER_X   = Math.round(W * 0.09);
    const R_TOWER_X   = Math.round(W * 0.91);
    return { groundBandH, groundTopY, GROUND_Y, L_TOWER_X, R_TOWER_X };
  }

  // ====== パラメータ ======
  const COIN_TICK = 3000, COIN_ADD = 8;
  const PX_PER_SPEED = 18;          // px/s
  const WALK_FPS = 6, ATK_FPS = 7;
  const MELEE_RANGE = 26;
  const RANGE_SHORT = 100;
  const RANGE_MEDIUM = 140;
  const RANGE_MEDIUM_PLUS = 160;
  const ATK_IDLE_PHASE = 0.18;      // 立ち→攻撃 切替に使用
  const ATK_TOTAL      = 0.36;

  // Projectile params
  const PROJ_SPEED_WIZ    = 230;
  const PROJ_SPEED_SHORT  = 200;  // ワルMOB
  const PROJ_SPEED_GOLEM  = 180;
  const PROJ_SPEED_ICE    = 200;
  const PROJ_SPEED_SHIELD = 210;
  const PROJ_HIT_R = 16;

  // ゴレムの壁
  const GOLEM_BLOCK_DIST = 26;
  const GOLEM_SLOW_RATE  = 0.25;

  // アイスロボ（大）
  const ICE_CHARGE_TIME  = 0.50;
  const ICE_CHARGE_MIN_S = 0.18;
  const ICE_CHARGE_MAX_S = 1.0;
  const HOP_AMP_BIG = 8;

  // ミニのホップ＆揺れ
  const HOP_AMP_MINI = 6;
  const SWAY_AMP_MINI = 3;    // x方向の見た目だけの揺れ(px)
  const SWAY_FREQ_MINI = 2.2; // 1/s

  // シールドの発射ディレイ（SL4→SL5→弾）
  const SHIELD_DELAY_SEC = 0.20;

  // ====== ユニット定義 ======
  const UNIT_KINDS = {
    BOX:   { name:"MOB段ボール",  hp:150, atk:20,  atkInt:1.0, speed:3, cost:50,  key:"BOX",   rangePx:MELEE_RANGE, scale:0.6,  hover:false, hop:false, proj:null },
    FTR:   { name:"MOBファイター", hp:120, atk:30,  atkInt:0.7, speed:5, cost:120, key:"FTR",   rangePx:MELEE_RANGE, scale:0.6,  hover:false, hop:false, proj:null },
    TEKI:  { name:"ワルMOB",       hp:100, atk:15,  atkInt:1.0, speed:3, cost:30,  key:"TEKI",  rangePx:80,           scale:0.6,  hover:false, hop:false,
             proj:{ imgKey:"short", speed:PROJ_SPEED_SHORT, maxTravel:120, wobble:true } },
    WIZ:   { name:"MOB ウィザード", hp:200, atk:80, atkInt:2.6, speed:2, cost:200, key:"WIZ",  rangePx:200,          scale:0.66, hover:true,  hop:false,
             proj:{ imgKey:"magic", speed:PROJ_SPEED_WIZ,   maxTravel:null, wobble:false } },
    GOLEM: { name:"MOBゴレムロボ", hp:600, atk:10,  atkInt:1.5, speed:1, cost:100, key:"GOLEM", rangePx:MELEE_RANGE,  scale:0.75, hover:false, hop:false,
             proj:{ imgKey:"golem", speed:PROJ_SPEED_GOLEM, maxTravel:90,  wobble:false } },
    ICE:   { name:"MOBアイスロボ", hp:900, atk:100, atkInt:2.5, speed:1, cost:200, key:"ICE",  rangePx:RANGE_MEDIUM, scale:0.75, hover:false, hop:true,
             proj:{ imgKey:"ice",   speed:PROJ_SPEED_ICE,   maxTravel:null, wobble:false, delayed:true, delaySec: ICE_CHARGE_TIME } },
    MINI:  { name:"MOBアイスロボミニ", hp:160, atk:23, atkInt:1.0, speed:2, cost:55, key:"MINI", rangePx:MELEE_RANGE, scale:0.58, hover:false, hop:true,
             proj:null, sway:true },
    SHIELD:{ name:"MOBシールド",   hp:500, atk:28, atkInt:1.6, speed:1, cost:110, key:"SHIELD", rangePx:RANGE_MEDIUM_PLUS, scale:0.72, hover:false, hop:false,
             proj:{ imgKey:"shield", speed:PROJ_SPEED_SHIELD, maxTravel:null, wobble:false, delayed:true, delaySec: SHIELD_DELAY_SEC } }
  };

  // ====== 画像読み込み ======
  function loadImage(src){
    return new Promise((res)=>{ const img=new Image(); img.src=src; img.onload=()=>res(img); img.onerror=()=>res(null); });
  }
  const assets = {};
  async function loadAll(){
    assets.bg = await loadImage(IMAGES.bg);
    assets.floor = await loadImage(IMAGES.floor);
    assets.towerL = await loadImage(IMAGES.towerL);
    assets.towerR = await loadImage(IMAGES.towerR);

    for(const key of ["BOX","FTR","TEKI","WIZ","GOLEM","ICE","MINI","SHIELD"]){
      const set = IMAGES[key];
      assets[key] = { idle:null, walk:[], atk:[], charge:null };
      assets[key].idle = await loadImage(set.idle);
      for(const s of (Array.isArray(set.walk)?set.walk:[set.walk])) assets[key].walk.push(await loadImage(s));
      for(const s of (Array.isArray(set.atk)?set.atk:[set.atk])) assets[key].atk.push(await loadImage(s));
      if(set.charge) assets[key].charge = await loadImage(set.charge);
    }
    // projectile
    assets.PROJ = {};
    assets.PROJ.magic  = await loadImage(IMAGES.PROJ.magic);
    assets.PROJ.short  = await loadImage(IMAGES.PROJ.short);
    assets.PROJ.golem  = await loadImage(IMAGES.PROJ.golem);
    assets.PROJ.ice    = await loadImage(IMAGES.PROJ.ice);
    assets.PROJ.shield = await loadImage(IMAGES.PROJ.shield);
  }

  // ====== 状態 ======
  let coins = 500; // テスト用スタート
  let lastCoinTick = 0, paused = false;
  let lastTime = performance.now(), fpsSmoothed = 60;

  const towerL = { x:0, y:0, hp:1200, side:+1 };
  const towerR = { x:0, y:0, hp:1200, side:-1 };

  const allies = [], enemies = [];
  const projectiles = [];
  const hits = [];

  // 敵は常に1体：倒れたら次を抽選で1体だけ
  let enemyActive = false;
  function pickEnemyKind(){
    const r = Math.random();
    let acc = 0;
    for(const k of ["BOX","MINI","SHIELD","ICE"]){
      acc += ENEMY_WEIGHTS[k] || 0;
      if(r <= acc) return k;
    }
    return "BOX";
  }

  // ====== 補助 ======
  function mixHex(a,b,t){
    function toRGB(h){const n=parseInt(h.slice(1),16);return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}}
    function toHex(r,g,b){return "#"+[r,g,b].map(v=>v.toString(16)).map(s=>s.padStart(2,"0")).join("")}
    const A=toRGB(a), B=toRGB(b);
    return toHex(
      Math.round(A.r*(1-t)+B.r*t),
      Math.round(A.g*(1-t)+B.g*t),
      Math.round(A.b*(1-t)+B.b*t)
    );
  }
  function drawImageCentered(ctx,img,cx,cy,w,h){
    if(!img){ ctx.fillStyle="#8886"; ctx.fillRect(cx-w/2, cy-h/2, w, h); return; }
    ctx.drawImage(img, cx-w/2, cy-h/2, w, h);
  }
  function flash(target){ hits.push({x:target.x, y:target.y-28, t:0}); }

  // ====== Projectile ======
  class Projectile{
    constructor({x,y,side,atk,imgKey,speed,maxTravel=null,wobble=false}){
      this.x=x; this.y=y; this.side=side; this.atk=atk; this.img=assets.PROJ[imgKey];
      this.angle=0; this.dead=false;
      this.speed=speed||220;
      this.startX = x;
      this.maxTravel = maxTravel; // null=無制限
      this.wobble = wobble;       // ふわっと揺れる
    }
    step(dt){
      this.x += (this.side>0?1:-1) * this.speed * dt;
      this.angle += (this.speed>=230 ? 10 : 6) * dt;
      const wobY = this.wobble ? Math.sin(this.x*0.08)*4 : 0;

      // 当たり（最短の生きた敵/味方）
      const foes = this.side>0 ? enemies : allies;
      for(const f of foes){
        if(f.state==="dead") continue;
        if(Math.abs(f.x - this.x) <= PROJ_HIT_R){
          f.hp -= this.atk; flash(f);
          this.dead=true; return;
        }
      }
      // タワー
      const foeTower = this.side>0 ? towerR : towerL;
      if(Math.abs(foeTower.x - this.x) <= PROJ_HIT_R){
        foeTower.hp -= this.atk; this.dead=true; return;
      }
      // 外/寿命
      if(this.x < -40 || this.x > W+40) this.dead=true;
      if(this.maxTravel!=null && Math.abs(this.x - this.startX) >= this.maxTravel) this.dead=true;

      this._wobY = wobY;
    }
    draw(ctx){
      const sz = 28;
      ctx.save();
      ctx.translate(this.x, (this.y - 28) + (this._wobY||0));
      ctx.rotate(this.angle);
      drawImageCentered(ctx, this.img, 0, 0, sz, sz);
      ctx.restore();
    }
  }

  // ====== Unit ======
  class Unit{
    constructor(kindKey, side){
      const def = UNIT_KINDS[kindKey];
      this.kind = kindKey; this.side = side;
      const g = geom();
      this.x = side>0 ? (g.L_TOWER_X + 28) : (g.R_TOWER_X - 28);
      this.y = g.GROUND_Y;
      this.maxHp = def.hp; this.hp = def.hp;
      this.atk = def.atk; this.atkInt = def.atkInt; this.cool=0;
      this.speed = def.speed * PX_PER_SPEED;
      this.scale = def.scale;
      this.rangePx = def.rangePx;
      this.hover = !!def.hover;
      this.hop   = !!def.hop;
      this.sway  = !!def.sway; // ミニ用：描画のみ横揺れ
      this.proj = def.proj;    // null または {imgKey, speed, maxTravel? , wobble?, delayed?, delaySec?}
      this.state = "walk"; this.animT = 0;
      this.firePending = false; // 遅延発射（ICE/SHIELD）
      this.fireDelaySec = 0;
    }
    width(){ return 64*this.scale; }
    height(){ return 64*this.scale; }

    findTarget(){
      const foes = this.side>0 ? enemies : allies;
      let nearest=null, best=Infinity;
      for(const f of foes){
        if(f.state==="dead") continue;
        const d = Math.abs(f.x - this.x);
        if(d<best){best=d; nearest=f;}
      }
      const foeTower = this.side>0 ? towerR : towerL;
      const dT = Math.abs(foeTower.x - this.x);
      if(dT<best){best=dT; nearest=foeTower;}
      return {target:nearest, dist:best};
    }

    static slowFactorNearGolem(unit){
      if(unit.kind==="GOLEM") return 1.0;
      const foes = unit.side>0 ? enemies : allies;
      for(const f of foes){
        if(f.state==="dead" || f.kind!=="GOLEM") continue;
        const dx = f.x - unit.x;
        if(unit.side>0 && dx>=0 && dx<=GOLEM_BLOCK_DIST) return GOLEM_SLOW_RATE;
        if(unit.side<0 && dx<=0 && -dx<=GOLEM_BLOCK_DIST) return GOLEM_SLOW_RATE;
      }
      return 1.0;
    }

    step(dt){
      if(this.state==="dead") return;
      this.cool = Math.max(0, this.cool - dt);
      const { target, dist } = this.findTarget();
      const inRange = target && dist <= this.rangePx;

      // 遅延発射（ICE/SHIELD など）
      if(this.state==="atk" && this.firePending && this.animT >= this.fireDelaySec){
        projectiles.push(new Projectile({
          x:this.x + (this.side>0?+12:-12), y:this.y,
          side:this.side, atk:this.atk,
          imgKey:this.proj.imgKey,
          speed:this.proj.speed || 220,
          maxTravel:this.proj.maxTravel ?? null,
          wobble:!!this.proj.wobble
        }));
        this.firePending=false;
      }

      if(inRange){
        if(this.cool===0){
          this.state="atk"; this.animT=0;
          if(this.proj){
            if(this.proj.delayed){
              this.firePending = true;
              this.fireDelaySec = this.proj.delaySec || 0.2;
            }else{
              projectiles.push(new Projectile({
                x:this.x + (this.side>0?+10:-10), y:this.y,
                side:this.side, atk:this.atk,
                imgKey:this.proj.imgKey,
                speed:this.proj.speed || 220,
                maxTravel:this.proj.maxTravel ?? null,
                wobble:!!this.proj.wobble
              }));
            }
          }else{
            if(target.hp!==undefined){ target.hp -= this.atk; flash(target); }
          }
          this.cool = this.atkInt;
        }
      }else{
        this.state="walk";
        let spd = this.speed * Unit.slowFactorNearGolem(this);
        this.x += this.side * spd * dt;
        const g = geom();
        const limitL = g.L_TOWER_X + 18;
        const limitR = g.R_TOWER_X - 18;
        if(this.side>0 && this.x>limitR) this.x = limitR;
        if(this.side<0 && this.x<limitL) this.x = limitL;
      }

      if(this.hp<=0) this.state="dead";
      this.animT += dt;
    }

    draw(ctx){
      if(this.state==="dead") return;
      const A = assets[UNIT_KINDS[this.kind].key];
      let img=null;

      // 浮遊/ホップ/揺れ
      const tNow = performance.now()/1000;
      const hoverY = this.hover ? Math.sin(tNow + this.x*0.01)*6 : 0;
      const hopY =
        (this.hop && this.state==="walk")
        ? -Math.abs(Math.sin(tNow*3 + this.x*0.02))*(this.kind==="ICE"?HOP_AMP_BIG:HOP_AMP_MINI) : 0;
      const swayX =
        (this.sway && this.state==="walk")
        ? Math.sin(tNow*SWAY_FREQ_MINI + this.x*0.05)*SWAY_AMP_MINI : 0;

      if(this.state==="walk"){
        img = A.walk[Math.floor(this.animT*WALK_FPS)%Math.max(1,A.walk.length)] || A.idle;

      }else if(this.state==="atk"){
        if(this.kind==="ICE"){
          const charging = this.animT < ICE_CHARGE_TIME;
          img = charging ? (A.charge || A.idle) : (A.atk[0] || A.idle);
        }else{
          // 立ち→攻撃（複数フレームに対応：例 シールド SL4→SL5）
          const phase = this.animT % ATK_TOTAL;
          if(phase < ATK_IDLE_PHASE){
            img = A.idle;
          }else{
            const len = Math.max(1, A.atk.length);
            const idx = Math.floor((phase-ATK_IDLE_PHASE) / (ATK_TOTAL-ATK_IDLE_PHASE) * len) % len;
            img = A.atk[idx] || A.idle;
          }
        }
      }else{
        img = A.idle;
      }

      const w=this.width(), h=this.height();
      const flip = this.side<0;
      ctx.save();
      ctx.translate(this.x + swayX, this.y + hoverY + hopY);
      if(flip) ctx.scale(-1,1);

      // 本体
      drawImageCentered(ctx, img, 0, -h*0.6, w, h);

      // アイス（大）の溜め可視化
      if(this.kind==="ICE" && this.state==="atk" && this.animT < ICE_CHARGE_TIME){
        const p = Math.min(1, this.animT/ICE_CHARGE_TIME);
        const s = ICE_CHARGE_MIN_S*(1-p) + ICE_CHARGE_MAX_S*p;
        const orb = assets.PROJ.ice;
        const offX = 14, offY = -h*0.68;
        drawImageCentered(ctx, orb, (flip?-offX:offX), offY, 24*s, 24*s);
      }

      ctx.restore();

      // HPバー
      const hpw = 46, hph=5, x = this.x - hpw/2, y = (this.y + hoverY + hopY) - h*0.9;
      const rate = Math.max(0,this.hp)/this.maxHp;
      ctx.fillStyle="#000000aa"; ctx.fillRect(x,y,hpw,hph);
      ctx.fillStyle = mixHex("#ef5350","#4caf50", rate);
      ctx.fillRect(x,y,hpw*rate,hph);
      ctx.strokeStyle="#1a263d"; ctx.strokeRect(x+0.5,y+0.5,hpw-1,hph-1);
    }
  }

  // ====== スポーン ======
  function spawnAlly(kind){
    const def = UNIT_KINDS[kind];
    if(coins < def.cost) return;
    coins -= def.cost;
    allies.push(new Unit(kind, +1));
    pulse(`{ ${def.name} 出撃 }`);
  }
  function spawnEnemy(kind){ enemies.push(new Unit(kind, -1)); }

  // ====== 進行 ======
  function step(dt){
    if(paused) return;
    const now = performance.now();
    if(now - lastCoinTick >= COIN_TICK){ coins += COIN_ADD; lastCoinTick = now; }

    // 敵：不在なら抽選して1体だけ出す
    if(!enemyActive){
      const k = pickEnemyKind();
      spawnEnemy(k);
      enemyActive = true;
    }

    for(const u of allies) u.step(dt);
    for(const u of enemies) u.step(dt);

    // プロジェクタイル
    for(const p of projectiles) p.step(dt);
    for(let i=projectiles.length-1;i>=0;i--) if(projectiles[i].dead) projectiles.splice(i,1);

    // 死亡掃除
    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].state==="dead") enemies.splice(i,1);
    for(let i=allies.length-1;i>=0;i--) if(allies[i].state==="dead") allies.splice(i,1);

    if(enemyActive && enemies.length===0) enemyActive=false;

    // ヒット演出
    for(let i=hits.length-1;i>=0;i--){ hits[i].t += dt; if(hits[i].t>0.25) hits.splice(i,1); }
  }

  function draw(){
    const g = geom();

    // 背景
    ctx.clearRect(0,0,W,H);
    if(assets.bg){
      const bg = assets.bg;
      const r = Math.max(W/bg.width, H/bg.height);
      const bw = bg.width*r, bh = bg.height*r;
      ctx.drawImage(bg, (W-bw)/2, (H-bh)/2, bw, bh);
    }else{
      ctx.fillStyle="#08111f"; ctx.fillRect(0,0,W,H);
    }

    // フロア（下部固定）
    if(assets.floor){
      const fh = g.groundBandH;
      const y  = g.groundTopY;
      const patternW = assets.floor.width;
      const scale = (fh / assets.floor.height);
      const drawW = patternW * scale;
      for(let x = -((Date.now()/70)%drawW); x<W+drawW; x+=drawW){
        ctx.drawImage(assets.floor, x, y, drawW, fh);
      }
    }else{
      ctx.fillStyle="#2c2c2c"; ctx.fillRect(0,g.groundTopY,W,g.groundBandH);
    }

    // タワー
    function drawTower(t, img){
      const th = Math.min(140, Math.round(H*0.22));
      const tw = Math.round(th * 0.6);
      const flip = t.side<0;
      ctx.save();
      ctx.translate(t.x, g.GROUND_Y);
      if(flip) ctx.scale(-1,1);
      drawImageCentered(ctx, img, 0, -th*0.62, tw, th);
      ctx.restore();
      const hpw = Math.round(W*0.22), hph=7, x=t.x-hpw/2, y=g.GROUND_Y - th*0.85;
      const rate = Math.max(0,t.hp)/1200;
      ctx.fillStyle="#000000aa"; ctx.fillRect(x,y,hpw,hph);
      ctx.fillStyle=mixHex("#ef5350","#4caf50", rate); ctx.fillRect(x,y,hpw*rate,hph);
      ctx.strokeStyle="#1a263d"; ctx.strokeRect(x+0.5,y+0.5,hpw-1,hph-1);
    }
    drawTower(towerL, assets.towerL);
    drawTower(towerR, assets.towerR);

    // ユニット（x順）
    const all = [...allies,...enemies].sort((a,b)=>a.x-b.x);
    for(const u of all) u.draw(ctx);

    // 弾
    for(const p of projectiles) p.draw(ctx);

    // ヒット演出
    for(const h of hits){
      const a = Math.max(0, 1 - h.t*4);
      ctx.save(); ctx.globalAlpha = a;
      ctx.fillStyle="#ffd180";
      ctx.beginPath(); ctx.arc(h.x, h.y, 10 + h.t*40, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // ====== ループ ======
  function loop(){
    if(paused) return;
    const now = performance.now();
    let dt = (now - lastTime)/1000; lastTime = now;
    dt = Math.min(dt, 0.05);
    step(dt); draw();
    coinsEl.textContent = coins|0;
    const inst = 1/dt; fpsSmoothed = fpsSmoothed*0.9 + inst*0.1; fpsEl.textContent = Math.round(fpsSmoothed);
    requestAnimationFrame(loop);
  }

  // ====== UI ======
  function pulse(t){
    msgEl.textContent = t; msgEl.style.display="block";
    clearTimeout(pulse._t); pulse._t = setTimeout(()=>{ msgEl.style.display="none"; }, 1000);
  }
  document.getElementById("btnBox").addEventListener("click", ()=>spawnAlly("BOX"));
  document.getElementById("btnFtr").addEventListener("click", ()=>spawnAlly("FTR"));
  document.getElementById("btnEvil").addEventListener("click", ()=>spawnAlly("TEKI"));
  document.getElementById("btnWiz").addEventListener("click", ()=>spawnAlly("WIZ"));
  document.getElementById("btnGolem").addEventListener("click", ()=>spawnAlly("GOLEM"));
  document.getElementById("btnIce").addEventListener("click", ()=>spawnAlly("ICE"));
  document.getElementById("btnMini").addEventListener("click", ()=>spawnAlly("MINI"));
  document.getElementById("btnShield").addEventListener("click", ()=>spawnAlly("SHIELD"));
  document.getElementById("pausePill").addEventListener("click", ()=>{
    paused = !paused;
    document.getElementById("pausePill").textContent = paused ? "▶ Resume" : "⏸ Pause";
    if(!paused){ lastTime = performance.now(); loop(); }
  });

  // ====== 起動 ======
  (async ()=>{
    await loadAll();
    const g = geom();
    towerL.x = g.L_TOWER_X; towerL.y = g.GROUND_Y;
    towerR.x = g.R_TOWER_X; towerR.y = g.GROUND_Y;
    lastCoinTick = performance.now();
    msgEl.style.display="block";
    lastTime = performance.now();
    loop();
  })();

})();
</script>
</body>
</html>
