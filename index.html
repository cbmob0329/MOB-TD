<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB TD â€“ æœ€å°ãƒ—ãƒ­ãƒˆ</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    /* ç”»é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆç¸¦ç”»é¢ãƒ™ãƒ¼ã‚¹ï¼‰ */
    --stage-w: 420px;    /* è¡¨ç¤ºé ˜åŸŸã®åŸºæº–å¹…ï¼ˆç¸¦ã‚¹ãƒãƒ›ã§è¦‹ã‚„ã™ã„å¹…ï¼‰ */
    --stage-h: 740px;    /* åŸºæº–é«˜ã• */
    /* UIè‰² */
    --hud-bg: #0e1118cc;
    --hud-fg: #e8f0ff;
    --hud-accent: #4dd0ff;
    --hp-green: #4caf50;
    --hp-red: #ef5350;
  }
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;touch-action: manipulation;overscroll-behavior:none}
  *{box-sizing:border-box}

  #root{position:fixed;inset:0;display:grid;place-items:center}
  #game{
    width:min(100vw, var(--stage-w));
    height:100dvh;
    max-height:var(--stage-h);
    position:relative; overflow:hidden; background:#000;
    border:1px solid #0e1522; border-radius:18px;
    box-shadow:0 14px 48px rgba(0,0,0,.5);
  }

  /* ã‚­ãƒ£ãƒ³ãƒã‚¹é ˜åŸŸ */
  #view{
    position:absolute; inset:0;
    image-rendering: pixelated;
    background:#000;
  }

  /* ä¸Šéƒ¨HUDï¼ˆã‚³ã‚¤ãƒ³ã€ã‚³ã‚¹ãƒˆã€ãƒãƒ¼ã‚ºç­‰ï¼‰ */
  .topbar{
    position:absolute; left:0; right:0; top:env(safe-area-inset-top);
    display:flex; align-items:center; gap:8px;
    padding:10px 12px;
    background:linear-gradient(to bottom, #000000b0, #00000040);
    pointer-events:none;
  }
  .pill{
    pointer-events:auto;
    background:var(--hud-bg); color:var(--hud-fg);
    border:1px solid #1b2638; border-radius:999px; padding:6px 10px; font-size:14px;
    display:flex; align-items:center; gap:8px;
    box-shadow:0 2px 8px rgba(0,0,0,.25);
  }
  .pill b{color:var(--hud-accent)}
  .spacer{flex:1}

  /* ä¸‹éƒ¨ã‚³ãƒãƒ³ãƒ‰ */
  .bottombar{
    position:absolute; left:0; right:0; bottom:calc(env(safe-area-inset-bottom) + 8px);
    display:flex; gap:10px; justify-content:center; padding:8px 10px;
  }
  .card{
    width:46%; max-width:220px;
    background:var(--hud-bg); color:var(--hud-fg);
    border:1px solid #1b2638; border-radius:14px; padding:10px;
    display:grid; gap:6px; text-align:center;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
  }
  .card h3{margin:0; font-size:14px; letter-spacing:.3px}
  .cost{font-size:12px; opacity:.9}
  .btn{
    appearance:none; border:1px solid #2a3751; background:#122034; color:#e9f3ff; border-radius:10px;
    padding:10px 12px; font-weight:700; font-size:14px; cursor:pointer;
    box-shadow:inset 0 0 0 1px #19314e, 0 2px 10px rgba(0,0,0,.25);
  }
  .btn:disabled{opacity:.5; filter:grayscale(.3); cursor:not-allowed}
  .hint{font-size:11px; opacity:.8}

  /* ç”»é¢ä¸­å¤®ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  .center-msg{
    position:absolute; left:50%; top:42%; transform:translate(-50%,-50%);
    padding:8px 12px; border-radius:10px; background:#00000099; border:1px solid #24324f;
    font-size:12px; text-align:center; pointer-events:none;
  }

  /* ç°¡æ˜“ãƒˆã‚°ãƒ« */
  .tiny{font-size:12px; opacity:.9}

</style>
</head>
<body>
<div id="root">
  <div id="game">
    <canvas id="view"></canvas>

    <div class="topbar">
      <div class="pill" id="coinBox">ğŸ’° <b id="coins">0</b></div>
      <div class="pill tiny" id="income">+8 / 3s</div>
      <div class="spacer"></div>
      <div class="pill tiny" id="fpsBox">FPS: <b id="fps">60</b></div>
      <div class="pill tiny" id="pausePill" style="cursor:pointer">â¸ Pause</div>
    </div>

    <div class="center-msg" id="msg">ç”»é¢ä¸‹ã®ãƒœã‚¿ãƒ³ã§ãƒ¦ãƒ‹ãƒƒãƒˆã‚’å‡ºæ’ƒã§ãã¾ã™</div>

    <div class="bottombar">
      <div class="card">
        <h3>MOBæ®µãƒœãƒ¼ãƒ«</h3>
        <div class="cost">ã‚³ã‚¹ãƒˆ <b>50</b> / HP150 / è¿‘æ¥</div>
        <button class="btn" id="btnBox">å‡ºæ’ƒ</button>
        <div class="hint">C1ã€œC4.png ã‚’ä½¿ç”¨</div>
      </div>
      <div class="card">
        <h3>MOBãƒ•ã‚¡ã‚¤ã‚¿ãƒ¼</h3>
        <div class="cost">ã‚³ã‚¹ãƒˆ <b>120</b> / HP120 / è¿‘æ¥ï¼ˆé€Ÿï¼‰</div>
        <button class="btn" id="btnFtr">å‡ºæ’ƒ</button>
        <div class="hint">EN1-1ã€œEN1-5.png ã‚’ä½¿ç”¨</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== ç”»åƒãƒ‘ã‚¹ï¼ˆåŒãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ã„ã¦ãã ã•ã„ï¼‰ ======
  const IMAGES = {
    bg: "sora.png",
    floor: "doro.png",
    towerL: "T1.png",
    towerR: "T2.png",
    BOX: {
      idle: "C1.png",
      walk: ["C2.png","C3.png"],      // 2æšãƒ«ãƒ¼ãƒ—
      atk:  "C4.png"
    },
    FTR: {
      idle: "EN1-1.png",
      walk: ["EN1-2.png","EN1-3.png"],// 2æšãƒ«ãƒ¼ãƒ—
      atk:  ["EN1-4.png","EN1-5.png"] // 2æšãƒ«ãƒ¼ãƒ—
    }
  };

  // ====== ã‚²ãƒ¼ãƒ å®šæ•° ======
  const W = 420;            // è«–ç†å¹…ï¼ˆç¸¦ç”»é¢å‘ã‘ï¼‰
  const H = 740;            // è«–ç†é«˜ã•
  const GROUND_Y = 540;     // ãƒ•ãƒ­ã‚¢åŸºæº–Yï¼ˆã‚­ãƒ£ãƒ©è¶³å…ƒãŒä¹—ã‚‹ãƒ©ã‚¤ãƒ³ï¼‰
  const L_TOWER_X = 48;     // å·¦ã‚¿ãƒ¯ãƒ¼X
  const R_TOWER_X = W - 48; // å³ã‚¿ãƒ¯ãƒ¼X
  const LANE_TOP = 320;     // ãƒ•ãƒ­ã‚¢ã‚¿ã‚¤ãƒ«è¡¨ç¤ºé–‹å§‹Y
  const COIN_TICK = 3000;   // ã‚³ã‚¤ãƒ³å¢—åˆ†é–“éš”(ms)
  const COIN_ADD = 8;       // 3ç§’ã§+8ï¼ˆåºç›¤ã®æ“ä½œæ„Ÿã‚’æƒ³å®šï¼‰
  const MELEE_RANGE = 26;   // è¿‘æ¥ãƒ¬ãƒ³ã‚¸(px)

  // é€Ÿåº¦ï¼ˆpx/secï¼‰ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®ç§»å‹•é€Ÿåº¦ã€Œ3ã€ã€Œ5ã€ã‚’è½ã¡ç€ã„ãŸä½“æ„Ÿã¸
  const PX_PER_SPEED = 18;  // 1ãƒ¬ãƒ™ãƒ«ã‚ãŸã‚Šã®ä¿‚æ•°ï¼š18px/s
  // ã‚¢ãƒ‹ãƒ¡é€Ÿåº¦
  const WALK_FPS = 6;       // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ 6fps
  const ATK_FPS  = 7;

  // ====== ãƒ¦ãƒ‹ãƒƒãƒˆè¨­è¨ˆï¼ˆæŒ‡å®šå€¤åæ˜ ï¼‰ ======
  const UNIT_KINDS = {
    BOX: {
      name: "MOBæ®µãƒœãƒ¼ãƒ«",
      hp: 150,
      atk: 20,
      atkInt: 1.0,
      speed: 3,     // ä¸­
      cost: 50,
      imgs: IMAGES.BOX,
      scale: 0.6    // å°ã•ã‚ã«è¡¨ç¤º
    },
    FTR: {
      name: "MOBãƒ•ã‚¡ã‚¤ã‚¿ãƒ¼",
      hp: 120,
      atk: 30,
      atkInt: 0.7,
      speed: 5,     // é€Ÿ
      cost: 120,
      imgs: IMAGES.FTR,
      scale: 0.6
    }
  };

  // ====== ã‚­ãƒ£ãƒ³ãƒã‚¹æº–å‚™ ======
  const canvas = document.getElementById("view");
  const ctx = canvas.getContext("2d");
  const gameEl = document.getElementById("game");
  function resizeCanvas(){
    canvas.width = W;
    // å®‰å…¨ã«ä¸Šä¸‹ã«ä½™ç™½ã‚’æ®‹ã—ã¤ã¤ã€UIãŒè¢«ã‚‰ãªã„ã‚ˆã†åŸºæº–é«˜ã‚’æ¡ç”¨
    canvas.height = H;
  }
  resizeCanvas();
  addEventListener("resize", resizeCanvas);

  // ====== ç”»åƒèª­ã¿è¾¼ã¿ ======
  function loadImage(src){
    return new Promise((res, rej) => {
      const img = new Image();
      img.src = src;
      img.onload = () => res(img);
      img.onerror = () => {
        console.warn("ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:", src);
        res(null); // å¤±æ•—ã—ã¦ã‚‚é€²è¡Œã§ãã‚‹ã‚ˆã†nullã§è§£æ±º
      };
    });
  }
  const assets = {};
  async function loadAll(){
    assets.bg = await loadImage(IMAGES.bg);
    assets.floor = await loadImage(IMAGES.floor);
    assets.towerL = await loadImage(IMAGES.towerL);
    assets.towerR = await loadImage(IMAGES.towerR);

    // ãƒ¦ãƒ‹ãƒƒãƒˆç”»åƒ
    for(const key of ["BOX","FTR"]){
      const set = IMAGES[key];
      assets[key] = { idle:null, walk:[], atk:[] };
      assets[key].idle = await loadImage(set.idle);
      const walkArr = Array.isArray(set.walk) ? set.walk : [set.walk];
      for(const s of walkArr) assets[key].walk.push(await loadImage(s));
      const atkArr = Array.isArray(set.atk) ? set.atk : [set.atk];
      for(const s of atkArr) assets[key].atk.push(await loadImage(s));
    }
  }

  // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
  let coins = 50; // é–‹å§‹æ™‚å°‘ã—ã ã‘
  let lastCoinTick = 0;
  let paused = false;

  // ã‚¿ãƒ¯ãƒ¼
  const towerL = { x:L_TOWER_X, y:GROUND_Y, hp: 1200, side: +1 }; // å‘³æ–¹
  const towerR = { x:R_TOWER_X, y:GROUND_Y, hp: 1200, side: -1 }; // æ•µ

  // ãƒ¦ãƒ‹ãƒƒãƒˆé…åˆ—
  const allies = [];
  const enemies = [];

  // æ•µã¯ã€Œ1ä½“ãšã¤ã€â€”å‰ãŒå€’ã‚ŒãŸã‚‰æ¬¡ã‚’å‡ºã™
  let enemyQueue = [
    { kind:"BOX" }, { kind:"BOX" }, { kind:"BOX" },
    { kind:"BOX" }, { kind:"BOX" }, { kind:"BOX" },
  ];
  let enemyActive = false;

  // FPSè¨ˆæ¸¬
  let lastTime = performance.now();
  let fpsSmoothed = 60;

  // ====== ãƒ¦ãƒ‹ãƒƒãƒˆã‚¯ãƒ©ã‚¹ ======
  class Unit {
    constructor(kindKey, side){
      const def = UNIT_KINDS[kindKey];
      this.kind = kindKey;
      this.side = side;              // +1:å³ã¸ï¼ˆå‘³æ–¹ï¼‰ -1:å·¦ã¸ï¼ˆæ•µï¼‰
      this.x = side>0 ? (towerL.x + 32) : (towerR.x - 32);
      this.y = GROUND_Y;
      this.maxHp = def.hp;
      this.hp = def.hp;
      this.atk = def.atk;
      this.atkInt = def.atkInt;
      this.cool = 0;
      this.speed = def.speed * PX_PER_SPEED; // px/s
      this.scale = def.scale;
      this.state = "walk"; // idle / walk / atk / dead
      this.animT = 0;
    }
    width(){ return 64 * this.scale; }   // æç”»åŸºæº–ï¼ˆå°ã•ã‚ï¼‰
    height(){ return 64 * this.scale; }

    // è¡çªãƒ»æ”»æ’ƒå¯¾è±¡æ¢ç´¢ï¼ˆå‰æ–¹æœ€çŸ­ï¼‰
    findTarget(){
      const foes = this.side>0 ? enemies : allies;
      let nearest = null;
      let best = Infinity;
      for(const f of foes){
        if(f.state==="dead") continue;
        const d = Math.abs(f.x - this.x);
        if(d < best){ best = d; nearest = f; }
      }
      // ã‚¿ãƒ¯ãƒ¼ã‚‚å¯¾è±¡
      const foeTower = this.side>0 ? towerR : towerL;
      const dT = Math.abs(foeTower.x - this.x);
      if(dT < best){ best = dT; nearest = foeTower; }
      return { target: nearest, dist: best };
    }

    step(dt){
      if(this.state==="dead") return;
      // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
      this.cool = Math.max(0, this.cool - dt);

      const { target, dist } = this.findTarget();

      const inRange = target ? dist <= MELEE_RANGE : false;

      if(inRange){
        // æ”»æ’ƒ
        if(this.cool===0){
          this.state = "atk";
          this.animT = 0;
          if(target.hp !== undefined){
            target.hp -= this.atk;
            // ãƒ’ãƒƒãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥
            flash(target);
          }
          this.cool = this.atkInt;
        }
      }else{
        // å‰é€²ï¼ˆé€Ÿã™ããªã„ã‚ˆã†æ•°å€¤ã‚’æ§ãˆã‚ã«ï¼‰
        this.state = "walk";
        this.x += this.side * this.speed * dt;
        // é€²ã¿éãé˜²æ­¢ï¼ˆã‚¿ãƒ¯ãƒ¼ã‚ã‚Šè¾¼ã¿å›é¿ï¼‰
        const limitL = towerL.x + 18;
        const limitR = towerR.x - 18;
        if(this.side>0 && this.x>limitR) this.x = limitR;
        if(this.side<0 && this.x<limitL) this.x = limitL;
      }

      // æ­»äº¡åˆ¤å®š
      if(this.hp<=0){
        this.state = "dead";
      }

      // ã‚¢ãƒ‹ãƒ¡æ™‚é–“
      this.animT += dt;
    }

    draw(ctx){
      if(this.state==="dead") return;
      const A = assets[this.kind];

      // ç”»åƒé¸æŠ
      let img = null;
      if(this.state==="walk"){
        const idx = Math.floor(this.animT * WALK_FPS) % Math.max(1, A.walk.length);
        img = A.walk[idx] || A.idle;
      }else if(this.state==="atk"){
        const idx = Math.floor(this.animT * ATK_FPS) % Math.max(1, A.atk.length);
        img = A.atk[idx] || A.idle;
      }else{
        img = A.idle;
      }
      const w = this.width(), h = this.height();
      const flip = this.side<0;

      ctx.save();
      ctx.translate(this.x, this.y);
      if(flip){ ctx.scale(-1,1); }
      // è¶³å…ƒåŸºæº–ã§æç”»ï¼ˆå°‘ã—ä¸Šã«ç½®ã„ã¦æ¥åœ°æ„Ÿï¼‰
      drawImageCentered(ctx, img, 0, -h*0.6, w, h);
      ctx.restore();

      // HPãƒãƒ¼ï¼ˆå°ã•ãï¼‰
      const hpw = 40, hph = 5, x = this.x - hpw/2, y = this.y - h*0.9;
      const hpRate = Math.max(0, this.hp) / this.maxHp;
      ctx.fillStyle = "#000000aa"; ctx.fillRect(x, y, hpw, hph);
      ctx.fillStyle = mixColor(getVar("--hp-red"), getVar("--hp-green"), hpRate);
      ctx.fillRect(x, y, hpw*hpRate, hph);
      ctx.strokeStyle = "#1a263d"; ctx.strokeRect(x+0.5, y+0.5, hpw-1, hph-1);
    }
  }

  // ====== ãƒ’ãƒƒãƒˆæ¼”å‡º ======
  const hits = [];
  function flash(target){
    hits.push({ x: target.x, y: target.y - 28, t: 0 });
  }

  // ====== æç”»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
  function drawImageCentered(ctx, img, cx, cy, w, h){
    if(!img){ // ä»£æ›¿ï¼šæ 
      ctx.fillStyle = "#8888";
      ctx.fillRect(cx - w/2, cy - h/2, w, h);
      return;
    }
    ctx.drawImage(img, cx - w/2, cy - h/2, w, h);
  }
  function getVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }
  function mixColor(a, b, t){
    // #rrggbb ã‚’ç·šå½¢è£œé–“
    function hexToRgb(s){ const n=parseInt(s.replace("#",""),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
    function rgbToHex(r,g,b){ return "#"+[r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("");}
    const A = hexToRgb(a), B = hexToRgb(b);
    const r = Math.round(A.r*(1-t)+B.r*t);
    const g = Math.round(A.g*(1-t)+B.g*t);
    const b2= Math.round(A.b*(1-t)+B.b*t);
    return rgbToHex(r,g,b2);
  }

  // ====== ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ======
  function step(dt){
    if(paused) return;

    // ã‚³ã‚¤ãƒ³è‡ªç„¶å¢—åŠ 
    const now = performance.now();
    if(now - lastCoinTick >= COIN_TICK){
      coins += COIN_ADD;
      lastCoinTick = now;
    }

    // æ•µã‚¹ãƒãƒ¼ãƒ³ï¼ˆ1ä½“ãšã¤ï¼‰
    if(!enemyActive && enemyQueue.length>0){
      spawnEnemy(enemyQueue.shift().kind);
      enemyActive = true;
    }

    // å„ãƒ¦ãƒ‹ãƒƒãƒˆæ›´æ–°
    for(const u of allies) u.step(dt);
    for(const u of enemies) u.step(dt);

    // æ­»äº¡æƒé™¤
    for(let i=enemies.length-1;i>=0;i--){
      if(enemies[i].state==="dead") enemies.splice(i,1);
    }
    for(let i=allies.length-1;i>=0;i--){
      if(allies[i].state==="dead") allies.splice(i,1);
    }

    // æ•µå´ï¼šå ´ã«ã„ãªã‘ã‚Œã°æ¬¡ã‚’å‡ºã™
    if(enemyActive && enemies.length===0){
      enemyActive = false;
    }

    // ã‚¿ãƒ¯ãƒ¼HP <= 0 ã§å‹æ•—
    if(towerL.hp<=0 || towerR.hp<=0){
      paused = true;
      const msg = document.getElementById("msg");
      msg.textContent = (towerR.hp<=0) ? "å‹åˆ©ï¼" : "æ•—åŒ—â€¦";
      msg.style.display = "block";
    }

    // ãƒ’ãƒƒãƒˆæ¼”å‡º
    for(let i=hits.length-1;i>=0;i--){
      hits[i].t += dt;
      if(hits[i].t>0.25) hits.splice(i,1);
    }
  }

  function draw(){
    // èƒŒæ™¯
    ctx.clearRect(0,0,W,H);
    if(assets.bg){
      // èƒŒæ™¯ã¯å…¨ä½“ã«ãƒ•ã‚£ãƒƒãƒˆï¼ˆä¸Šä¸‹å„ªå…ˆï¼‰
      const bg = assets.bg;
      const ratio = Math.max(W/bg.width, H/bg.height);
      const bw = bg.width*ratio, bh = bg.height*ratio;
      ctx.drawImage(bg, (W-bw)/2, (H-bh)/2, bw, bh);
    }else{
      ctx.fillStyle = "#0a0f1a"; ctx.fillRect(0,0,W,H);
    }

    // ãƒ•ãƒ­ã‚¢ï¼ˆä¸Šéƒ¨ã‚’æ­©ãã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰
    if(assets.floor){
      const fh = 140; // è¡¨ç¤ºé«˜ã•
      const y = LANE_TOP;
      const patternW = assets.floor.width;
      const scale = (fh / assets.floor.height);
      const drawW = patternW * scale;
      for(let x= -((Date.now()/50)%drawW); x<W+drawW; x+=drawW){
        ctx.drawImage(assets.floor, x, y, drawW, fh);
      }
    }else{
      ctx.fillStyle = "#2c2c2c";
      ctx.fillRect(0, LANE_TOP, W, 140);
    }

    // ã‚¿ãƒ¯ãƒ¼
    function drawTower(t, img){
      const tw = 84, th = 140;
      const flip = t.side<0;
      ctx.save();
      ctx.translate(t.x, GROUND_Y);
      if(flip) ctx.scale(-1,1);
      drawImageCentered(ctx, img, 0, -th*0.62, tw, th);
      ctx.restore();

      // HPãƒãƒ¼
      const hpw = 90, hph=7, x = t.x - hpw/2, y = GROUND_Y - 120;
      const rate = Math.max(0,t.hp)/1200;
      ctx.fillStyle = "#000000aa"; ctx.fillRect(x,y,hpw,hph);
      ctx.fillStyle = mixColor(getVar("--hp-red"), getVar("--hp-green"), rate);
      ctx.fillRect(x,y,hpw*rate,hph);
      ctx.strokeStyle = "#1a263d"; ctx.strokeRect(x+0.5,y+0.5,hpw-1,hph-1);
    }
    drawTower(towerL, assets.towerL);
    drawTower(towerR, assets.towerR);

    // ã‚½ãƒ¼ãƒˆã—ã¦æç”»ï¼ˆXã§OKï¼‰
    const all = [...allies, ...enemies].sort((a,b)=>a.x-b.x);
    for(const u of all) u.draw(ctx);

    // ãƒ’ãƒƒãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    for(const h of hits){
      const a = Math.max(0, 1 - h.t*4);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = "#ffd180";
      ctx.beginPath();
      ctx.arc(h.x, h.y, 10 + h.t*40, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ====== ã‚¹ãƒãƒ¼ãƒ³å‡¦ç† ======
  function spawnAlly(kind){
    const def = UNIT_KINDS[kind];
    if(coins < def.cost) return;
    coins -= def.cost;
    allies.push(new Unit(kind, +1));
    pulseMsg(`${def.name} å‡ºæ’ƒï¼`);
  }
  function spawnEnemy(kind){
    enemies.push(new Unit(kind, -1));
  }

  // ====== å½“ãŸã‚Šåˆ¤å®šã¨ã‚¿ãƒ¯ãƒ¼æ”»æ’ƒï¼ˆè¿‘æ¥åœå†…ã®ã¨ãï¼‰ ======
  // Unit.stepå†…ã§å¯¾è±¡æ¤œç´¢â†’ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ã‚¿ãƒ¯ãƒ¼å´ã®æ­»äº¡å‡¦ç†ã ã‘è¿½åŠ 
  const _origStep = Unit.prototype.step;

  Unit.prototype.step = function(dt){
    _origStep.call(this, dt);
    // ã‚¿ãƒ¯ãƒ¼æ­»äº¡æ™‚ã«HP0åˆ¶å¾¡ï¼ˆè² æ•°æš´èµ°é˜²æ­¢ï¼‰
    if(towerL.hp<0) towerL.hp = 0;
    if(towerR.hp<0) towerR.hp = 0;

    // ã‚¿ãƒ¯ãƒ¼ãŒå¯¾è±¡ã®ã¨ãã¯Unit.findTarget()å†…ã§hpã‚’æ¸›ã‚‰ã—ã¦ã„ã‚‹
    // ã‚¿ãƒ¯ãƒ¼ãŒå€’ã‚ŒãŸã‚‰æ¼”å‡ºã¯drawå´ã®HPãƒãƒ¼ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§å®Œçµ
  };

  // ====== UI ======
  const coinsEl = document.getElementById("coins");
  const fpsEl = document.getElementById("fps");
  const msgEl = document.getElementById("msg");
  function pulseMsg(t){
    msgEl.textContent = t;
    msgEl.style.display = "block";
    clearTimeout(pulseMsg._t);
    pulseMsg._t = setTimeout(()=>{ msgEl.style.display="none"; }, 1200);
  }

  document.getElementById("btnBox").addEventListener("click", () => spawnAlly("BOX"));
  document.getElementById("btnFtr").addEventListener("click", () => spawnAlly("FTR"));
  document.getElementById("pausePill").addEventListener("click", () => {
    paused = !paused;
    document.getElementById("pausePill").textContent = paused ? "â–¶ Resume" : "â¸ Pause";
    if(!paused){ lastTime = performance.now(); loop(); }
  }, {passive:true});

  // ====== ãƒ«ãƒ¼ãƒ— ======
  function loop(){
    if(paused) return;
    const now = performance.now();
    let dt = (now - lastTime) / 1000;
    lastTime = now;
    // å¤§ãã„ãƒ•ãƒ¬ãƒ¼ãƒ è½ã¡å¸å
    dt = Math.min(dt, 0.05);

    step(dt);
    draw();

    // HUDæ›´æ–°
    coinsEl.textContent = coins|0;
    // FPSç°¡æ˜“
    const inst = 1/dt;
    fpsSmoothed = fpsSmoothed*0.9 + inst*0.1;
    fpsEl.textContent = Math.round(fpsSmoothed);

    requestAnimationFrame(loop);
  }

  // ====== èµ·å‹• ======
  (async () => {
    await loadAll();
    // åˆæœŸã‚¹ãƒãƒ¼ãƒ³ï¼ˆæ•µã¯æœ€åˆã¯å‡ºã•ãšã€å‘³æ–¹å‡ºæ’ƒã‚’ä¿ƒã™ï¼‰
    lastCoinTick = performance.now();
    msgEl.style.display = "block";
    lastTime = performance.now();
    loop();
  })();

})();
</script>
</body>
</html>
